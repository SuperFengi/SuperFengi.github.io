<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-12-30T15:24:23.876Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Docker学习</title>
    <link href="http://example.com/2022/12/30/docker/"/>
    <id>http://example.com/2022/12/30/docker/</id>
    <published>2022-12-29T16:00:00.000Z</published>
    <updated>2022-12-30T15:24:23.876Z</updated>
    
    <content type="html"><![CDATA[<p>跟着狂神哥学docker</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="docker的由来"><a href="#docker的由来" class="headerlink" title="docker的由来"></a>docker的由来</h2><p>Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。</p><h2 id="docker与传统虚拟机的区别"><a href="#docker与传统虚拟机的区别" class="headerlink" title="docker与传统虚拟机的区别"></a>docker与传统虚拟机的区别</h2><p>传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；</p><p>而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。</p><p>每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。</p><h2 id="相关网站"><a href="#相关网站" class="headerlink" title="相关网站"></a>相关网站</h2><p>Docker官网：<a href="http://www.docker.com/">http://www.docker.com</a></p><p>Docker中文网站：<a href="https://www.docker-cn.com/">https://www.docker-cn.com</a></p><p>Docker Hub官网：<a href="https://hub.docker.com/">https://hub.docker.com</a> </p><h1 id="docker的基本组成"><a href="#docker的基本组成" class="headerlink" title="docker的基本组成"></a>docker的基本组成</h1><h2 id="构架图"><a href="#构架图" class="headerlink" title="构架图"></a>构架图</h2><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221228154551534.png" alt="image-20221228154551534"></p><h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><p>Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 就好似 Java 中的 类和对象，类就是镜像，容器就是对象。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。</p><p>它可以被启动、开始、停止、删除。每个容器都是相互隔离的，保证安全的平台。</p><p>可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。</p><p>容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。</p><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>仓库（Repository）是集中存放镜像文件的场所。</p><p>仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。</p><p>仓库分为公开仓库（Public）和私有仓库（Private）两种形式。</p><h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><p>Docker是一个<strong>Client-Server</strong>结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。</p><h3 id="docker更快的原因"><a href="#docker更快的原因" class="headerlink" title="docker更快的原因"></a>docker更快的原因</h3><p>1、docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。</p><p>2、docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。</p><h1 id="docker命令"><a href="#docker命令" class="headerlink" title="docker命令"></a>docker命令</h1><h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 列出本地主机上的镜像</span><br><span class="line">[root@d3f4u1t ~]# docker images</span><br><span class="line">REPOSITORY    TAG      IMAGE ID       CREATED       SIZE</span><br><span class="line">hello-world  latest  bf756fb1ae65   4 months ago   23.3kB</span><br><span class="line"></span><br><span class="line"># 解释</span><br><span class="line">REPOSITORY 镜像的仓库源</span><br><span class="line">TAG 镜像的标签</span><br><span class="line">IMAGE ID 镜像的ID</span><br><span class="line">CREATED 镜像创建时间</span><br><span class="line">SIZE 镜像大小</span><br><span class="line"></span><br><span class="line"># 同一个仓库源可以有多个 TAG，代表这个仓库源的不同版本，我们使用REPOSITORY：TAG 定义不同</span><br><span class="line">的镜像，如果你不定义镜像的标签版本，docker将默认使用 lastest 镜像！</span><br><span class="line"></span><br><span class="line"># 可选项</span><br><span class="line">-a： 列出本地所有镜像</span><br><span class="line">-q： 只显示镜像id</span><br><span class="line">--digests： 显示镜像的摘要信息</span><br></pre></td></tr></table></figure><h3 id="docker-search"><a href="#docker-search" class="headerlink" title="docker search"></a>docker search</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 搜索镜像</span><br><span class="line">[root@d3f4u1t ~]# docker search mysql</span><br><span class="line">NAME DESCRIPTION STARS</span><br><span class="line">OFFICIAL</span><br><span class="line">mysql MySQL is a widely used, open-source relation… 9484</span><br><span class="line">[OK]</span><br><span class="line"></span><br><span class="line"># docker search 某个镜像的名称 对应DockerHub仓库中的镜像</span><br><span class="line"></span><br><span class="line"># 可选项</span><br><span class="line">--filter=stars=50 ： 列出收藏数不小于指定值的镜像。</span><br></pre></td></tr></table></figure><h3 id="docker-pull"><a href="#docker-pull" class="headerlink" title="docker pull"></a>docker pull</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 下载镜像</span><br><span class="line">[root@d3f4u1t ~]# docker pull mysql</span><br><span class="line">Using default tag: latest # 不写tag，默认是latest最新版本</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">54fec2fa59d0: Already exists # 分层下载</span><br><span class="line">bcc6c6145912: Already exists</span><br><span class="line">951c3d959c9d: Already exists</span><br><span class="line">05de4d0e206e: Already exists</span><br><span class="line">319f0394ef42: Already exists</span><br><span class="line">d9185034607b: Already exists</span><br><span class="line">013a9c64dadc: Already exists</span><br><span class="line">42f3f7d10903: Pull complete</span><br><span class="line">c4a3851d9207: Pull complete</span><br><span class="line">Digest:</span><br><span class="line">sha256:61a2a33f4b8b4bc93b7b6b9e65e64044aaec594809f818aeffbff69a893d1944 #</span><br><span class="line">签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest # 真实位置</span><br><span class="line"># 指定版本下载</span><br><span class="line">[root@d3f4u1t ~]# docker pull mysql:5.7</span><br><span class="line">....</span><br></pre></td></tr></table></figure><h3 id="docker-rmi"><a href="#docker-rmi" class="headerlink" title="docker rmi"></a>docker rmi</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 删除镜像</span><br><span class="line">docker rmi -f 镜像id # 删除单个</span><br><span class="line">docker rmi -f 镜像名:tag 镜像名:tag # 删除多个</span><br><span class="line">docker rmi -f $(docker images -qa) # 删除全部</span><br></pre></td></tr></table></figure><h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p>有镜像才能创建容器，这里使用 centos 的镜像来测试，就是虚拟一个 centos </p><h3 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a><strong>新建容器并启动</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker run [OPTIONS] IMAGE [COMMAND][ARG...]</span><br><span class="line"></span><br><span class="line"># 常用参数说明</span><br><span class="line">--name=&quot;Name&quot; # 给容器指定一个名字</span><br><span class="line">-d # 后台方式运行容器，并返回容器的id！</span><br><span class="line">-i # 以交互模式运行容器，通过和 -t 一起使用</span><br><span class="line">-t # 给容器重新分配一个终端，通常和 -i 一起使用</span><br><span class="line">-P # 随机端口映射（大写）</span><br><span class="line">-p # 指定端口映射（小结），一般可以有四种写法</span><br><span class="line">ip:hostPort:containerPort</span><br><span class="line">ip::containerPort</span><br><span class="line">hostPort:containerPort (常用)</span><br><span class="line">containerPort</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">[root@d3f4u1t ~]# docker images</span><br><span class="line">REPOSITORY  TAG      IMAGE ID      CREATED       SIZE</span><br><span class="line">centos     latest  470671670cac  3 months ago    237MB</span><br><span class="line"></span><br><span class="line"># 使用centos进行用交互模式启动容器，在容器内执行/bin/bash命令！</span><br><span class="line">[root@d3f4u1t ~]# docker run -it centos /bin/bash</span><br><span class="line">[root@dc8f24dd06d0 /]# ls # 注意地址，已经切换到容器内部了！</span><br><span class="line">bin etc lib lost+found mnt proc run srv tmp var</span><br><span class="line">dev home lib64 media opt root sbin sys usr</span><br></pre></td></tr></table></figure><h3 id="列出所有运行的容器"><a href="#列出所有运行的容器" class="headerlink" title="列出所有运行的容器"></a>列出所有运行的容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker ps [OPTIONS]</span><br><span class="line"></span><br><span class="line"># 常用参数说明</span><br><span class="line">-a # 列出当前所有正在运行的容器 + 历史运行过的容器</span><br><span class="line">-l # 显示最近创建的容器</span><br><span class="line">-n=? # 显示最近n个创建的容器</span><br><span class="line">-q # 静默模式，只显示容器编号。</span><br></pre></td></tr></table></figure><h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit # 容器停止退出</span><br><span class="line">ctrl+P+Q # 容器不停止退出</span><br></pre></td></tr></table></figure><h3 id="启动时停止容器"><a href="#启动时停止容器" class="headerlink" title="启动时停止容器"></a>启动时停止容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start (容器id or 容器名) # 启动容器</span><br><span class="line">docker restart (容器id or 容器名) # 重启容器</span><br><span class="line">docker stop (容器id or 容器名) # 停止容器</span><br><span class="line">docker kill (容器id or 容器名) # 强制停止容器</span><br></pre></td></tr></table></figure><h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id # 删除指定容器</span><br><span class="line">docker rm -f $(docker ps -a -q) # 删除所有容器</span><br><span class="line">docker ps -a -q|xargs docker rm # 删除所有容器</span><br></pre></td></tr></table></figure><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker run -d 容器名</span><br><span class="line"></span><br><span class="line"># 例子</span><br><span class="line">docker run -d centos # 启动centos，使用后台方式启动</span><br><span class="line"></span><br><span class="line"># 问题： 使用docker ps 查看，发现容器已经退出了！</span><br><span class="line"># 解释：Docker容器后台运行，就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命</span><br><span class="line">令，就会自动退出。</span><br><span class="line"># 比如，你运行了nginx服务，但是docker前台没有运行应用，这种情况下，容器启动后，会立即自</span><br><span class="line">杀，因为他觉得没有程序了，所以最好的情况是，将你的应用使用前台进程的方式运行启动。</span><br></pre></td></tr></table></figure><h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker logs -f -t --tail 容器id</span><br><span class="line"># eg:</span><br><span class="line">[root@d3f4u1t ~]# docker run -d centos /bin/sh -c &quot;while true;do echo kuangshen;sleep 1;done&quot;</span><br><span class="line"></span><br><span class="line">[root@d3f4u1t ~]# docker ps</span><br><span class="line">CONTAINER ID IMAGE</span><br><span class="line">c8530dbbe3b4 centos</span><br><span class="line"></span><br><span class="line"># -t 显示时间戳</span><br><span class="line"># -f 打印最新的日志</span><br><span class="line"># --tail 数字 显示多少条！</span><br><span class="line"></span><br><span class="line">[root@d3f4u1t ~]# docker logs -tf --tail 10 c8530dbbe3b4</span><br><span class="line">2020-05-11T08:46:40.656901941Z kuangshen</span><br><span class="line">2020-05-11T08:46:41.658765018Z kuangshen</span><br><span class="line">2020-05-11T08:46:42.661015375Z kuangshen</span><br><span class="line">2020-05-11T08:46:43.662865628Z kuangshen</span><br><span class="line">2020-05-11T08:46:44.664571547Z kuangshen</span><br><span class="line">2020-05-11T08:46:45.666718583Z kuangshen</span><br><span class="line">2020-05-11T08:46:46.668556725Z kuangshen</span><br><span class="line">2020-05-11T08:46:47.670424699Z kuangshen</span><br><span class="line">2020-05-11T08:46:48.672324512Z kuangshen</span><br><span class="line">2020-05-11T08:46:49.674092766Z kuangshen</span><br></pre></td></tr></table></figure><h3 id="查看容器中运行的进程信息，支持ps命令参数。"><a href="#查看容器中运行的进程信息，支持ps命令参数。" class="headerlink" title="查看容器中运行的进程信息，支持ps命令参数。"></a>查看容器中运行的进程信息，支持ps命令参数。</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker top 容器id</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">[root@kuangshen ~]# docker top c8530dbbe3b4</span><br><span class="line">UID    PID   PPID   C   STIME   TTY   TIME        CMD</span><br><span class="line">root  27437  27421  0   16:43    ?   00:00:00   /bin/sh -c ....</span><br></pre></td></tr></table></figure><h3 id="查看容器镜像的元数据"><a href="#查看容器镜像的元数据" class="headerlink" title="查看容器镜像的元数据"></a>查看容器镜像的元数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker inspect 容器id</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">[root@d3f4u1t ~]# docker inspect c8530dbbe3b4</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line"># 完整的id，这里上面的容器id，就是截取的这个id前几位</span><br><span class="line">&quot;Id&quot;:</span><br><span class="line">&quot;c8530dbbe3b44a0c873f2566442df6543ed653c1319753e34b400efa05f77cf8&quot;,</span><br><span class="line">&quot;Created&quot;: &quot;2020-05-11T08:43:45.096892382Z&quot;,</span><br><span class="line">&quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">&quot;Args&quot;: [</span><br><span class="line">&quot;-c&quot;,</span><br><span class="line">&quot;while true;do echo kuangshen;sleep 1;done&quot;</span><br><span class="line">],</span><br><span class="line"># 状态</span><br><span class="line">&quot;State&quot;: &#123;</span><br><span class="line">&quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">&quot;Running&quot;: true,</span><br><span class="line">&quot;Paused&quot;: false,</span><br><span class="line">&quot;Restarting&quot;: false,</span><br><span class="line">&quot;OOMKilled&quot;: false,</span><br><span class="line">&quot;Dead&quot;: false,</span><br><span class="line">&quot;Pid&quot;: 27437,</span><br><span class="line">&quot;ExitCode&quot;: 0,</span><br><span class="line">&quot;Error&quot;: &quot;&quot;,</span><br><span class="line">&quot;StartedAt&quot;: &quot;2020-05-11T08:43:45.324474622Z&quot;,</span><br><span class="line">&quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">&#125;,</span><br><span class="line">// ...........</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="进入正在运行的容器"><a href="#进入正在运行的容器" class="headerlink" title="进入正在运行的容器"></a>进入正在运行的容器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"># 命令1</span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"></span><br><span class="line"># 测试1</span><br><span class="line">[root@d3f4u1t ~]# docker ps</span><br><span class="line">CONTAINER ID IMAGE COMMAND CREATED</span><br><span class="line">STATUS PORTS NAMES</span><br><span class="line">c8530dbbe3b4 centos &quot;/bin/sh -c &#x27;while t…&quot; 12 minutes</span><br><span class="line">ago Up 12 minutes happy_chaum</span><br><span class="line">[root@d3f4u1t ~]# docker exec -it c8530dbbe3b4 /bin/bash</span><br><span class="line">[root@c8530dbbe3b4 /]# ps -ef</span><br><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">root 1 0 0 08:43 ? 00:00:00 /bin/sh -c while true;do</span><br><span class="line">echo kuangshen;sleep</span><br><span class="line">root 751 0 0 08:56 pts/0 00:00:00 /bin/bash</span><br><span class="line">root 769 1 0 08:56 ? 00:00:00 /usr/bin/coreutils --</span><br><span class="line">coreutils-prog-shebang=s</span><br><span class="line">root 770 751 0 08:56 pts/0 00:00:00 ps -ef</span><br><span class="line"></span><br><span class="line"># 命令2</span><br><span class="line">docker attach 容器id</span><br><span class="line"></span><br><span class="line"># 测试2</span><br><span class="line">[root@d3f4u1t ~]# docker exec -it c8530dbbe3b4 /bin/bash</span><br><span class="line">[root@c8530dbbe3b4 /]# ps -ef</span><br><span class="line">UID PID PPID C STIME TTY TIME CMD</span><br><span class="line">root 1 0 0 08:43 ? 00:00:00 /bin/sh -c while true;do</span><br><span class="line">echo kuangshen;sleep</span><br><span class="line">root 856 0 0 08:57 pts/0 00:00:00 /bin/bash</span><br><span class="line">root 874 1 0 08:57 ? 00:00:00 /usr/bin/coreutils --</span><br><span class="line">coreutils-prog-shebang=s</span><br><span class="line">root 875 856 0 08:57 pts/0 00:00:00 ps -ef</span><br><span class="line"></span><br><span class="line"># 区别</span><br><span class="line"># exec 是在容器中打开新的终端，并且可以启动新的进程</span><br><span class="line"># attach 直接进入容器启动命令的终端，不会启动新的进程</span><br></pre></td></tr></table></figure><h3 id="从容器中拷贝内容到主机上"><a href="#从容器中拷贝内容到主机上" class="headerlink" title="从容器中拷贝内容到主机上"></a>从容器中拷贝内容到主机上</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker cp 容器id:容器内路径 目的主机路径</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line"># 容器内执行，创建一个文件测试</span><br><span class="line">[root@c8530dbbe3b4 /]# cd /home</span><br><span class="line">[root@c8530dbbe3b4 home]# touch f1</span><br><span class="line">[root@c8530dbbe3b4 home]# ls</span><br><span class="line">f1</span><br><span class="line">[root@c8530dbbe3b4 home]# exit</span><br><span class="line">exit</span><br><span class="line"></span><br><span class="line"># linux复制查看，是否复制成功</span><br><span class="line">[root@d3f4u1t ~]# docker cp c8530dbbe3b4:/home/f1 /home</span><br><span class="line">[root@d3f4u1t ~]# cd /home</span><br><span class="line">[root@d3f4u1t home]# ls</span><br><span class="line">f1</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221228211456019.png" alt="image-20221228211456019"></p><p>常用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">attach: Attach to a running container # 当前 shell 下attach 连接指定运行镜像</span><br><span class="line"></span><br><span class="line">build: Build an image from a Dockerfile # 通过 Dockerfile 定制镜像</span><br><span class="line"></span><br><span class="line">commit: Create a new image from a container changes # 提交当前容器为新的镜像</span><br><span class="line"></span><br><span class="line">cp: Copy files/folders from the containers filesystem to the host path</span><br><span class="line">#从容器中拷贝指定文件或者目录到宿主机中</span><br><span class="line"></span><br><span class="line">create: Create a new container # 创建一个新的容器，同run，但不启动容器</span><br><span class="line"></span><br><span class="line">diff: Inspect changes on a container&#x27;s filesystem # 查看 docker 容器变化</span><br><span class="line"></span><br><span class="line">events: Get real time events from the server # 从 docker 服务获取容器实时事件</span><br><span class="line"></span><br><span class="line">exec: Run a command in an existing container # 在已存在的容器上运行命令</span><br><span class="line"></span><br><span class="line">export: Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]</span><br><span class="line"></span><br><span class="line">history: Show the history of an image # 展示一个镜像形成历史</span><br><span class="line"></span><br><span class="line">images: List images # 列出系统当前镜像</span><br><span class="line"></span><br><span class="line">import: Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]</span><br><span class="line"></span><br><span class="line">info: Display system-wide information # 显示系统相关信息</span><br><span class="line"></span><br><span class="line">inspect: Return low-level information on a container # 查看容器详细信息</span><br><span class="line"></span><br><span class="line">kill: Kill a running container # kill 指定 docker 容器</span><br><span class="line"></span><br><span class="line">load: Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]</span><br><span class="line"></span><br><span class="line">login: Register or Login to the docker registry server # 注册或者登陆一个docker 源服务器</span><br><span class="line"></span><br><span class="line">logout: Log out from a Docker registry server # 从当前 Dockerregistry 退出</span><br><span class="line"></span><br><span class="line">logs: Fetch the logs of a container # 输出当前容器日志信息</span><br><span class="line"></span><br><span class="line">port: Lookup the public-facing port which is NAT-ed to PRIVATE_PORT #查看映射端口对应的容器内部源端口</span><br><span class="line"></span><br><span class="line">pause: Pause all processes within a container # 暂停容器</span><br><span class="line"></span><br><span class="line">ps: List containers # 列出容器列表</span><br><span class="line"></span><br><span class="line">pull: Pull an image or a repository from the docker registry server #从docker镜像源服务器拉取指定镜像或者库镜像</span><br><span class="line"></span><br><span class="line">push: Push an image or a repository to the docker registry server #推送指定镜像或者库镜像至docker源服务器</span><br><span class="line"></span><br><span class="line">restart: Restart a running container # 重启运行的容器</span><br><span class="line"></span><br><span class="line">rm: Remove one or more containers # 移除一个或者多个容器</span><br><span class="line"></span><br><span class="line">rmi: Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]</span><br><span class="line"></span><br><span class="line">run: Run a command in a new container # 创建一个新的容器并运行一个命令</span><br><span class="line"></span><br><span class="line">save: Save an image to a tar archive # 保存一个镜像为一个tar 包[对应 load]</span><br><span class="line"></span><br><span class="line">search: Search for an image on the Docker Hub # 在 docker hub 中搜索镜像</span><br><span class="line"></span><br><span class="line">start: Start a stopped containers # 启动容器</span><br><span class="line"></span><br><span class="line">stop: Stop a running containers # 停止容器</span><br><span class="line"></span><br><span class="line">tag: Tag an image into a repository # 给源中镜像打标签</span><br><span class="line"></span><br><span class="line">top: Lookup the running processes of a container # 查看容器中运行的进程信息</span><br><span class="line"></span><br><span class="line">unpause: Unpause a paused container # 取消暂停容器</span><br><span class="line"></span><br><span class="line">version: Show the docker version information # 查看 docker 版本号</span><br><span class="line"></span><br><span class="line">wait: Block until a container stops, then print its exit code # 截取容器停止时的退出状态值</span><br></pre></td></tr></table></figure><h1 id="docker镜像详解"><a href="#docker镜像详解" class="headerlink" title="docker镜像详解"></a>docker镜像详解</h1><h2 id="何为镜像"><a href="#何为镜像" class="headerlink" title="何为镜像"></a>何为镜像</h2><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。</p><h2 id="加载原理"><a href="#加载原理" class="headerlink" title="加载原理"></a>加载原理</h2><p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p><p>bootfs(boot fifile system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p><p>rootfs (root fifile system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p><h2 id="分层结构"><a href="#分层结构" class="headerlink" title="分层结构"></a>分层结构</h2><p>docker镜像采用分层结构，最大的好处莫过于资源共享。比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p><p>理解：</p><p>所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221230225349259.png" alt="image-20221230225349259"></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部</p><p>这一层就是我们通常说的容器层，容器之下的都叫镜像层</p><h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h2 id="何为容器数据卷"><a href="#何为容器数据卷" class="headerlink" title="何为容器数据卷"></a>何为容器数据卷</h2><p>卷就是目录或者文件，存在一个或者多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System ， 提供一些用于持续存储或共享数据的特性：</p><p>卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。</p><p>特点：</p><p>1、数据卷可在容器之间共享或重用数据</p><p>2、卷中的更改可以直接生效</p><p>3、数据卷中的更改不会包含在镜像的更新中</p><p>4、数据卷的生命周期一直持续到没有容器使用它为止</p><h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><h3 id="方式一：命令行"><a href="#方式一：命令行" class="headerlink" title="方式一：命令行"></a>方式一：命令行</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 命令</span><br><span class="line">docker run -it -v 宿主机绝对路径目录:容器内目录 镜像名</span><br><span class="line"></span><br><span class="line"># 测试</span><br><span class="line">[root@d3f4u1t ~]# docker run -it -v /home/ceshi:/home centos /bin/bash</span><br></pre></td></tr></table></figure><p>挂载分为匿名挂载和具名挂载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 匿名挂载</span><br><span class="line">-v 容器内路径</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"># 匿名挂载的缺点，就是不好维护，通常使用命令 docker volume维护</span><br><span class="line">docker volume ls</span><br><span class="line"></span><br><span class="line"># 具名挂载</span><br><span class="line">-v 卷名:/容器内路径</span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx nginx</span><br><span class="line"></span><br><span class="line"># 查看挂载的路径</span><br><span class="line">[root@d3f4u1t ~]# docker volume inspect nginxconfig</span><br><span class="line">[</span><br><span class="line">&#123;</span><br><span class="line">&quot;CreatedAt&quot;: &quot;2020-05-13T17:23:00+08:00&quot;,</span><br><span class="line">&quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">&quot;Labels&quot;: null,</span><br><span class="line">&quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/nginxconfig/_data&quot;,</span><br><span class="line">&quot;Name&quot;: &quot;nginxconfig&quot;,</span><br><span class="line">&quot;Options&quot;: null,</span><br><span class="line">&quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># 怎么判断挂载的是卷名而不是本机目录名？</span><br><span class="line">不是/开始就是卷名，是/开始就是目录名</span><br><span class="line"># 改变文件的读写权限</span><br><span class="line"># ro: readonly</span><br><span class="line"># rw: readwrite</span><br><span class="line"></span><br><span class="line"># 指定容器对我们挂载出来的内容的读写权限</span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure><h3 id="方式二：dockerfile"><a href="#方式二：dockerfile" class="headerlink" title="方式二：dockerfile"></a>方式二：dockerfile</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># 1、我们在宿主机 /home 目录下新建一个 docker-test-volume文件夹</span><br><span class="line">[root@d3f4u1t home]# mkdir docker-test-volume</span><br><span class="line"></span><br><span class="line"># 说明：在编写DockerFile文件中使用 VOLUME 指令来给镜像添加一个或多个数据卷</span><br><span class="line">VOLUME[&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer</span><br><span class="line">3&quot;]</span><br><span class="line"></span><br><span class="line"># 出于可移植和分享的考虑，我们之前使用的 -v 主机目录:容器目录 这种方式不能够直接在</span><br><span class="line">DockerFile中实现。</span><br><span class="line"># 由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有宿主机上都存在这样的特定目录.</span><br><span class="line"></span><br><span class="line"># 2、编写DockerFile文件</span><br><span class="line">[root@d3f4u1t docker-test-volume]# pwd</span><br><span class="line">/home/docker-test-volume</span><br><span class="line">[root@d3f4u1t docker-test-volume]# vim dockerfile1</span><br><span class="line">[root@d3f4u1t docker-test-volume]# cat dockerfile1</span><br><span class="line"># volume test</span><br><span class="line">FROM centos</span><br><span class="line">VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]</span><br><span class="line">CMD echo &quot;-------end------&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"></span><br><span class="line"># 3、build后生成镜像，获得一个新镜像 d3f4u1t/centos</span><br><span class="line">docker build -f /home/docker-test-volume/dockerfile1 -t kuangshen/centos . </span><br><span class="line">#注意最后有个.</span><br><span class="line"></span><br><span class="line"># 4、启动容器</span><br><span class="line">[root@d3f4u1tn docker-test-volume]# docker run -it 0e97e1891a3d /bin/bash </span><br><span class="line">#启动容器</span><br><span class="line">[root@f5824970eefc /]# ls -l</span><br><span class="line">total 56</span><br><span class="line">lrwxrwxrwx 1 root root 7 May 11 2019 bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x 2 root root 4096 May 11 11:55 dataVolumeContainer1 # 数据卷目录</span><br><span class="line">drwxr-xr-x 2 root root 4096 May 11 11:55 dataVolumeContainer2 # 数据卷目录</span><br><span class="line">drwxr-xr-x 5 root root 360 May 11 11:55 dev</span><br><span class="line">drwxr-xr-x 1 root root 4096 May 11 11:55 etc</span><br><span class="line">drwxr-xr-x 2 root root 4096 May 11 2019 home</span><br><span class="line">.....</span><br><span class="line"># 问题:通过上述步骤，容器内的卷目录地址就已经知道了，但是对应的主机目录地址在哪里呢？</span><br><span class="line"></span><br><span class="line"># 5、我们在数据卷中新建一个文件</span><br><span class="line">[root@f5824970eefc dataVolumeContainer1]# pwd</span><br><span class="line">/dataVolumeContainer1</span><br><span class="line">[root@f5824970eefc dataVolumeContainer1]# touch container.txt</span><br><span class="line">[root@f5824970eefc dataVolumeContainer1]# ls -l</span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root 0 May 11 11:58 container.txt</span><br><span class="line"></span><br><span class="line"># 6、查看下这个容器的信息</span><br><span class="line">[root@d3f4u1t ~]# docker inspect 0e97e1891a3d</span><br><span class="line"># 查看输出的Volumes</span><br><span class="line">&quot;Volumes&quot;: &#123;</span><br><span class="line">&quot;/dataVolumeContainer1&quot;: &#123;&#125;,</span><br><span class="line">&quot;/dataVolumeContainer2&quot;: &#123;&#125;</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"># 7、这个卷在主机对应的默认位置</span><br></pre></td></tr></table></figure><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。</p><p><strong>容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。</strong></p><p><strong>存储在本机的文件则会一直保留</strong></p><h1 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h1><h2 id="何为dockerfile"><a href="#何为dockerfile" class="headerlink" title="何为dockerfile"></a>何为dockerfile</h2><p>dockerfifile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。</p><p>构建步骤：</p><p>1、编写DockerFile文件</p><p>2、docker build 构建镜像</p><p>3、docker run</p><h2 id="构建dockerfile"><a href="#构建dockerfile" class="headerlink" title="构建dockerfile"></a>构建dockerfile</h2><p><strong>基础知识：</strong></p><p>1、每条保留字指令(命令)都必须为大写字母且后面要跟随至少一个参数</p><p>2、指令按照从上到下，顺序执行</p><p>3、# 表示注释</p><p>4、每条指令都会创建一个新的镜像层，并对镜像进行提交</p><p><strong>流程：</strong></p><p>1、docker从基础镜像运行一个容器</p><p>2、执行一条指令并对容器做出修改</p><p>3、执行类似 docker commit 的操作提交一个新的镜像层</p><p>4、Docker再基于刚提交的镜像运行一个新容器</p><p>5、执行dockerfifile中的下一条指令直到所有指令都执行完成！</p><h2 id="dockerfile指令"><a href="#dockerfile指令" class="headerlink" title="dockerfile指令"></a>dockerfile指令</h2><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">FROM # 基础镜像，当前新镜像是基于哪个镜像的</span><br><span class="line">MAINTAINER # 镜像维护者的姓名混合邮箱地址</span><br><span class="line">RUN # 容器构建时需要运行的命令</span><br><span class="line">EXPOSE # 当前容器对外保留出的端口</span><br><span class="line">WORKDIR # 指定在创建容器后，终端默认登录的进来工作目录，一个落脚点</span><br><span class="line">ENV # 用来在构建镜像过程中设置环境变量</span><br><span class="line">ADD # 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包</span><br><span class="line">COPY # 类似ADD，拷贝文件和目录到镜像中！</span><br><span class="line">VOLUME # 容器数据卷，用于数据保存和持久化工作</span><br><span class="line">CMD # 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最</span><br><span class="line">后一个生效！</span><br><span class="line">ENTRYPOINT # 指定一个容器启动时要运行的命令！和CMD一样</span><br><span class="line">ONBUILD # 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的ONBUILD被触发</span><br></pre></td></tr></table></figure><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221230231454355.png" alt="image-20221230231454355"></p><h3 id="CMD-和-ENTRYPOINT-的区别"><a href="#CMD-和-ENTRYPOINT-的区别" class="headerlink" title="CMD 和 ENTRYPOINT 的区别"></a>CMD 和 ENTRYPOINT 的区别</h3><p>我们之前说过，两个命令都是指定一个容器启动时要运行的命令</p><p><strong>CMD</strong>：Dockerfile 中可以有多个CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换</p><p><strong>ENTRYPOINT</strong>： docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;跟着狂神哥学docker&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;h2 id=&quot;docker的由来&quot;&gt;&lt;a href=&quot;#docker的由来&quot; class=&quot;header</summary>
      
    
    
    
    <category term="wiki" scheme="http://example.com/categories/wiki/"/>
    
    
    <category term="docker" scheme="http://example.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>2022RCTF</title>
    <link href="http://example.com/2022/12/14/2022rctf/"/>
    <id>http://example.com/2022/12/14/2022rctf/</id>
    <published>2022-12-13T16:00:00.000Z</published>
    <updated>2022-12-28T09:11:14.310Z</updated>
    
    <content type="html"><![CDATA[<p>坐牢坐牢坐牢orz</p><h1 id="ez-alient"><a href="#ez-alient" class="headerlink" title="ez_alient"></a>ez_alient</h1><p>alien.bmp文件尾部存在压缩包解压密码</p><p>解压后文件查看文件头发现为可执行文件，运行后发现为pygame即pyexe</p><p>使用pyinstxtractor.py解包可得pyc文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py alien_invasion.exe</span><br></pre></td></tr></table></figure><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221214221459545.png" alt="image-20221214221459545"></p><p>同路径下会出现的[xxx.exe]_extracted的文件夹里面就包含了主程序main，但不带任何后缀，我们要反编译的就是这个文件，其他的都是依赖库，如PYZ-extracted文件夹里的都是库文件（用于import）。</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221214221835997.png" alt="image-20221214221835997"></p><p>至于为什么该文件不是.pyc文件，应该是pyinstxtractor的一点不足，转换出来的主程序格式不对，因此还需要对其进行手动修复。<br>这里了解下不同版本python下pyc文件头的结构（<a href="https://blog.csdn.net/Zheng__Huang/article/details/112380221">链接</a>）：</p><p>Python3.3以下的版本中，只有<strong>Magic Number</strong>和<strong>四位时间戳</strong>（共8字节）<br>Python3.3到Python3.7（不包含3.7）版本中，只有<strong>Magic Numbe</strong>r和<strong>八位时间戳</strong> + <strong>大小信息</strong>（共12字节）<br>Python3.7及以上版本的编译后二进制文件中，头部除了<strong>四字节Magic Number</strong>，还有<strong>四个字节的空位</strong>和<strong>八个字节的时间戳</strong> + <strong>大小信息</strong>（共16字节），后者（指后12字节）对文件反编译没有影响，全部填充0即可</p><p><strong>python Magic Number对照表</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">enum PycMagic &#123;    </span><br><span class="line">MAGIC_1_0 = 0x00999902,    </span><br><span class="line">MAGIC_1_1 = 0x00999903, /* Also covers 1.2 */    </span><br><span class="line">MAGIC_1_3 = 0x0A0D2E89,    </span><br><span class="line">MAGIC_1_4 = 0x0A0D1704,    </span><br><span class="line">MAGIC_1_5 = 0x0A0D4E99,    </span><br><span class="line">MAGIC_1_6 = 0x0A0DC4FC,     </span><br><span class="line">MAGIC_2_0 = 0x0A0DC687,    </span><br><span class="line">MAGIC_2_1 = 0x0A0DEB2A,    </span><br><span class="line">MAGIC_2_2 = 0x0A0DED2D,    </span><br><span class="line">MAGIC_2_3 = 0x0A0DF23B,    </span><br><span class="line">MAGIC_2_4 = 0x0A0DF26D,    </span><br><span class="line">MAGIC_2_5 = 0x0A0DF2B3,    </span><br><span class="line">MAGIC_2_6 = 0x0A0DF2D1,    </span><br><span class="line">MAGIC_2_7 = 0x0A0DF303,     </span><br><span class="line">MAGIC_3_0 = 0x0A0D0C3A,    </span><br><span class="line">MAGIC_3_1 = 0x0A0D0C4E,    </span><br><span class="line">MAGIC_3_2 = 0x0A0D0C6C,    </span><br><span class="line">MAGIC_3_3 = 0x0A0D0C9E,    </span><br><span class="line">MAGIC_3_4 = 0x0A0D0CEE,    </span><br><span class="line">MAGIC_3_5 = 0x0A0D0D16,    </span><br><span class="line">MAGIC_3_5_3 = 0x0A0D0D17,    </span><br><span class="line">MAGIC_3_6 = 0x0A0D0D33,    </span><br><span class="line">MAGIC_3_7 = 0x0A0D0D42,    </span><br><span class="line">MAGIC_3_8 = 0x0A0D0D55,    </span><br><span class="line">MAGIC_3_9 = 0x0A0D0D61, &#125;;</span><br></pre></td></tr></table></figure><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221228171112963.png" alt="image-20221228171112963"></p><p>根据其他解包好的pyc文件头且这里是py38，第一行添加16个字节去修主函数即可成功逆向</p><p>这里发现其他pyc即使解包出来也没办法直接逆（？，和上面主函数第一行修改一致即可成功逆向</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221214222400577.png" alt="image-20221214222400577"></p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221214222425476.png" alt="image-20221214222425476"></p><p>以上内容大致意思就是文件头格式不对（<a href="https://blog.csdn.net/weixin_43335392/article/details/125124297">链接</a>）</p><p>依照主函数的第一行修改如下：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221214222626053.png" alt="image-20221214222626053"></p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221214222641799.png" alt="image-20221214222641799"></p><p>逆完后面的步骤就比较简单了，主文件及其中引用到的库函数中均存在一个base64后的片段，解码后拼接即可。</p><h1 id="ez-pvz"><a href="#ez-pvz" class="headerlink" title="ez_pvz"></a>ez_pvz</h1><p>逆向大佬都是ida梭的orz</p><p>我当时只用ce通了一关，一直想锁定阳光的基址（奈何失败qaq</p><p>做法：</p><p>第一关：搜100，种豌豆，搜0，确定阳光临时地址</p><p>第二关：开局搜150，几十个数，挨个改为0，前几个改完查看游戏就发现找到了双豌豆和樱桃炸弹的费用地址，修改为零即可</p><p>第三关：做法同第二关，找到费用地址后查看内存，可以发现动态变化的内存地址即cd的变化地址，其<strong>后面</strong>的一个字节也会随着前面的变化规律变化，观察一会发现会从01（满cd）递增到10（无cd），一直修改为10即可实现无cd</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221214224559923.png" alt="image-20221214224559923"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;坐牢坐牢坐牢orz&lt;/p&gt;
&lt;h1 id=&quot;ez-alient&quot;&gt;&lt;a href=&quot;#ez-alient&quot; class=&quot;headerlink&quot; title=&quot;ez_alient&quot;&gt;&lt;/a&gt;ez_alient&lt;/h1&gt;&lt;p&gt;alien.bmp文件尾部存在压缩包解压密码&lt;/p</summary>
      
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="比赛" scheme="http://example.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>⎛⎝龙猫⎠⎞</title>
    <link href="http://example.com/2022/12/12/Totoro/"/>
    <id>http://example.com/2022/12/12/Totoro/</id>
    <published>2022-12-11T16:00:00.000Z</published>
    <updated>2022-12-12T15:17:43.541Z</updated>
    
    <content type="html"><![CDATA[<p>lazzzaro师傅出的一道题</p><p>下载附件改后缀为.zip</p><p>解压出一张打不开的图片和带密码的压缩包</p><p>打不开的图片的16进制头与正常jpg比较后发现规律</p><p>0101修改为正常图片得到：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221212223822607.png" alt="image-20221212223822607"></p><p>发现图片16进制尾部隐藏的信息，转两次hex得到：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221212224021597.png" alt="image-20221212224021597"></p><p>得到压缩包密码并提示进行异或</p><p>起初以为是对key文件进行异或，并且key文件与2B异或完确实还能得到一张图片</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221212224134883.png" alt="image-20221212224134883"></p><p>后来发现相偏了，这里考查的并不是双图隐写</p><p>因为key文件导入到010保存后的大小是和totoro.jpg一样的，所以是用key直接和totoro.jpg逐字节异或</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">f1=open(r&#x27;C:\Users\19682\Desktop\Totoro.jpg&#x27;,&#x27;rb&#x27;)</span><br><span class="line">f11=f1.read()</span><br><span class="line">f2=open(r&#x27;C:\Users\19682\Desktop\key&#x27;,&#x27;rb&#x27;)</span><br><span class="line">f22=f2.read()</span><br><span class="line">print(len(f11))</span><br><span class="line">print(len(f22))</span><br><span class="line">res=&#x27;&#x27;</span><br><span class="line">for i in range(len(f11)):</span><br><span class="line">    res+=chr(f11[i]^f22[i])</span><br><span class="line"></span><br><span class="line">b=open(&#x27;1234&#x27;,&#x27;w&#x27;)</span><br><span class="line">b.write(res)</span><br><span class="line">f1.close()</span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure><p>得到的文件导入010得：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221212224727962.png" alt="image-20221212224727962"></p><p>在众多+号中存在一段特殊序列，包含+[&gt;&lt;-.]，即两个问号中间得部分</p><p>复制到brainfuck解密得到flag</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221212225225310.png" alt="image-20221212225225310"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;lazzzaro师傅出的一道题&lt;/p&gt;
&lt;p&gt;下载附件改后缀为.zip&lt;/p&gt;
&lt;p&gt;解压出一张打不开的图片和带密码的压缩包&lt;/p&gt;
&lt;p&gt;打不开的图片的16进制头与正常jpg比较后发现规律&lt;/p&gt;
&lt;p&gt;0101修改为正常图片得到：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;ht</summary>
      
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="刷题记录" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>ShowTime</title>
    <link href="http://example.com/2022/12/12/ShowTime/"/>
    <id>http://example.com/2022/12/12/ShowTime/</id>
    <published>2022-12-11T16:00:00.000Z</published>
    <updated>2022-12-12T15:17:40.202Z</updated>
    
    <content type="html"><![CDATA[<p>Tokeii师傅在i春秋上出的一道题，挺新奇的，记录一下</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221212225834839.png" alt="image-20221212225834839"></p><p>思路源于他的这篇<a href="https://blog.csdn.net/u010418732/article/details/125178250?spm=1001.2014.3001.5502">博客</a></p><p>下载后的附件，名字都是base64编码的，写脚本改名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p=r&#x27;C:\Users\19682\Desktop\stego&#123;&#125;&#x27;.format(&#x27;\\&#x27;)</span><br><span class="line">for i in filelist:</span><br><span class="line">    b=i[:-4]</span><br><span class="line">    a=base64.b64decode(b)</span><br><span class="line">    c=a.decode(&#x27;UTF-8&#x27;)</span><br><span class="line">    d=os.rename(p+i,p+c+&#x27;.txt&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221212230030820.png" alt="image-20221212230030820"></p><p>提取每个文件修改时间戳的最后一位</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">for i in range(925):</span><br><span class="line">    filename = r&quot;C:\Users\19682\Desktop\stego\&#123;&#125;.txt&quot;.format(i)</span><br><span class="line">    file_attr = os.stat(filename)#读取文件属性</span><br><span class="line">    create_time = str(file_attr.st_mtime)#获取修改时间</span><br><span class="line">    # print(create_time)</span><br><span class="line">    print(int(create_time[9:10]),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>将数字转字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from numlib import *</span><br><span class="line">a=1774674557824868457499061032120895601890679002715594296727500711025736399907449201395656994728720806964341210442762667972497818255944821704615312664370539310702290900650405564784263444957700019095984690444788205828883771674746086773438649406269794894162345496646835920006634655790770023591140601368298957582899939643842210521270729599027362038934484123582308984705653794101554567102555263227506545092094002357706759680210528515040207139078660910227189154726011658251525180920105580373673544062554076786313766549322038531510544996944293029774158028502472577209425526755227464619459049995527828690565067923263594211663575768777749797684020900044480050567580861721772084896501068329188549341576999149193729307442677823665245077311594986800407693715823937313065541334395357854650051549808442561638033762084503042808464197473992558178954715114984494063565778497512453063854507422273051449037068016131470694073345956605305655737661</span><br><span class="line">print (n2s(a))</span><br></pre></td></tr></table></figure><p>得到一串base64</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221212230901285.png" alt="image-20221212230901285"></p><p>拿到cyberchef解码保存为7z文件解压后打开即得flag</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Tokeii师傅在i春秋上出的一道题，挺新奇的，记录一下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221212225834839.png&quot; alt</summary>
      
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="刷题记录" scheme="http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>首届“天权信安&amp;catf1ag”网络安全联合公开赛</title>
    <link href="http://example.com/2022/12/09/catflag/"/>
    <id>http://example.com/2022/12/09/catflag/</id>
    <published>2022-12-08T16:00:00.000Z</published>
    <updated>2022-12-11T15:51:45.928Z</updated>
    
    <content type="html"><![CDATA[<p>比赛介绍：<br>本次竞赛旨在通过以赛促学、以赛促进的竞赛提升方式，面向网络安全从业者、兴趣爱好者、在校学生，通过竞技比武，检验参赛人员的网络安全综合能力，培养和选拔一批高素质网络安全人才，进而营造良好的网络安全知识学习和技能提升氛围，吸引更多高校学生投身网络强国建设事业，推动网络安全人才的培养，以及加快高校网络安全人才的储备，为国家网络安全建设添砖加瓦，为行业技术提升创新贡献自己的力量。</p><p>比赛总结：</p><p>赛题难度适中，自身仍有很大提升空间orz</p><h1 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h1><h2 id="疑惑"><a href="#疑惑" class="headerlink" title="疑惑"></a><strong>疑惑</strong></h2><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 题目介绍：我好&quot;疑惑&quot;啊</span><br><span class="line"># keys1 = welcome_to_nine-ak_match_is_so_easy_!@!</span><br><span class="line"># keys2 = 20 4 24 5 94 12 2 36 26 6 49 11 68 15 14 114 12 10 43 14 9 43 10 27 31 31 22 45 10 48 58 4 18 10 38 31 14 97 92</span><br><span class="line">a=[20,4,24,5,94,12,2,36,26,6,49,11,68,15,14,114,12,10,43,14,9,43,10,27,31,31,22,45,10,48,58,4,18,10,38,31,14,97,92]</span><br><span class="line">b=&#x27;welcome_to_nine-ak_match_is_so_easy_!@!&#x27;</span><br><span class="line">for i in range(len(b)):</span><br><span class="line">    print(chr(ord(b[i])^a[i]),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>catf1ag{nine-ak_match_is@very_easy_@&#x2F;!} </p><h2 id="easyrsa"><a href="#easyrsa" class="headerlink" title="easyrsa"></a><strong>easyrsa</strong></h2><p>exp：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">e = 0x10001</span><br><span class="line">d=12344766091434434733173074189627377553017680360356962089159282442350343171988536143126785315325155784049041041740294461592715296364871912847202681353107182427067350160760722505537695351060872358780516757652343767211907987297081728669843916949983336698385141593880433674937737932158161117039734886760063825649623992179585362400642056715249145349214196969590250787495038347519927017407204272334005860911299915001920451629055970214564924913446260348649062607855669069184216149660211811217616624622378241195643396616228441026080441013816066477785035557421235574948446455413760957154157952685181318232685147981777529010093</span><br><span class="line">c=11665709552346194520404644475693304343544277312139717618599619856028953672850971126750357095315011211770308088484683204061365343120233905810281045824420833988717463919084545209896116273241788366262798828075566212041893949256528106615605492953529332060374278942243879658004499423676775019309335825331748319484916607746676069594715000075912334306124627379144493327297854542488373589404460931325101587726363963663368593838684601095345900109519178235587636259017532403848656471367893974805399463278536349688131608183835495334912159111202418065161491440462011639125641718883550113983387585871212805400726591849356527011578</span><br><span class="line">n=13717871972706962868710917190864395318380380788726354755874864666298971471295805029284299459288616488109296891203921497014120460143184810218680538647923519587681857800257311678203773339140281665350877914208278709865995451845445601706352659259559793431372688075659019308448963678380545045143583181131530985665822655263963917413080872997526445384954610888776917323156325542921415838122754036103689148810677276471252057077595104724365967333418002158480223657363936976281758713027828747277980907153645847605403914070601944617432177385048803228970693240587900504431163155958465431312258451026447435473865563581029300541109</span><br><span class="line">m=pow(c,d,n)</span><br><span class="line">print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><p>flag{3895dfda-67b1-11ed-b784-b07b2568d266}</p><h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a><strong>passwd</strong></h2><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from hashlib import *</span><br><span class="line"></span><br><span class="line">a=&#x27;&#x27;</span><br><span class="line">for i in range(1,13):</span><br><span class="line">    for j in range(1,32):</span><br><span class="line">        for m in range(1,25):</span><br><span class="line">            for n in range(1,61):</span><br><span class="line">                c=&#x27;2022&#x27;+str(&quot;%02d&quot; % i)+&#x27;&#x27;+str(&quot;%02d&quot; % j)+&#x27;&#x27;+str(&quot;%02d&quot; % m)+&#x27;&#x27;+str(&quot;%02d&quot; % n)+&#x27;&#x27;</span><br><span class="line">                d=sha256(c.encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line">                if d==&#x27;69d00d9bc39e01687abf84e98e27c889cf1442b53edba27d3235acbeb7b0ae95&#x27;:</span><br><span class="line">                    print(c)</span><br></pre></td></tr></table></figure><p>catf1ag{202211121750} </p><h1 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h1><h2 id="十位马"><a href="#十位马" class="headerlink" title="十位马"></a><strong>十位马</strong></h2><p>将文件里的16进制放到cyberchef转hex再倒序，以zip格式保存</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221209181915693.png" alt="image-20221209181915693"></p><p>打开发现一对正方形图片</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221209182110041.png" alt="image-20221209182110041"></p><p>根据具有顺序的名字，考虑进行拼图</p><p>脚本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import binascii</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">a=Image.new(&#x27;RGB&#x27;,(300,300),&#x27;white&#x27;)</span><br><span class="line">n=0</span><br><span class="line">for i in range(10):</span><br><span class="line">    for j in range(10):</span><br><span class="line">        b=Image.open(f&#x27;./WHAT_1S_FLAG/WHAT_1S_FLAG_&#123;n&#125;.png&#x27;)</span><br><span class="line">        a.paste(b,(30*j,30*i))</span><br><span class="line">        n+=1</span><br><span class="line">a.save(&#x27;7.png&#x27;)</span><br></pre></td></tr></table></figure><p>拼好的图片：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221209182224527.png" alt="image-20221209182224527"></p><p>手动ps上两个定位符，到在线网站进行识别</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221209182326207.png" alt="image-20221209182326207"></p><p>flag{cbef4c93-5e9c-11ed-8205-666c80085daf}</p><h2 id="简单隐写（复现）"><a href="#简单隐写（复现）" class="headerlink" title="简单隐写（复现）"></a><strong>简单隐写</strong>（复现）</h2><p>图片尾部存在rar压缩包，kali里面dd命令分离</p><p>压缩包加密</p><p>由于没有见过这种隐写，一直也没有写出来</p><p>考查jphide隐写</p><p>使用jphs无密码解密</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211212406344.png" alt="image-20221211212406344"></p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211212436987.png" alt="image-20221211212436987"></p><p>主要也不清楚该隐写有什么特征，问群友说一个一个试，还是见得太少了orz</p><p>使用密码解压</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211212625774.png" alt="image-20221211212625774"></p><p>凯撒密码：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211212723989.png" alt="image-20221211212723989"></p><h2 id="阿sir（复现）"><a href="#阿sir（复现）" class="headerlink" title="阿sir（复现）"></a><strong>阿sir</strong>（复现）</h2><p>以为相对拿手的电子取证来了，结果到快结束才找到能解这个零宽的网站orz</p><p>零宽解密:</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211213136129.png" alt="image-20221211213136129"></p><p>取证大师挂载</p><p>发现桌面上的一张图片16进制末尾有东西</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211214832995.png" alt="image-20221211214832995"></p><p>将megrez前面的字母和数字以及最后的’&#x3D;‘提取出来</p><p>得到</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211215218695.png" alt="image-20221211215218695"></p><p>解一下base</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211215333849.png" alt="image-20221211215333849"></p><p>缓存记录里可以看到缓存了两个百度网盘的文件</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211220106436.png" alt="image-20221211220106436"></p><p>上面的密码解不开</p><p>后来发现是最后一个是大写字母I而不是小写字母l</p><p>有点脑洞有点坑。。。</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211220225618.png" alt="image-20221211220225618"></p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211220237325.png" alt="image-20221211220237325"></p><p>给了图片和一些名字不同的压缩包，压缩包名在传递信息，结合图片名中的stego应该是lsb隐写</p><p>人为创的压缩包肯定存在创建的时间顺序</p><p>写脚本解一下名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">filelist = os.listdir(r&#x27;C:\Users\19682\Desktop\123&#x27;)</span><br><span class="line">dir_list = sorted(filelist,key=lambda x: os.path.getmtime(os.path.join(r&#x27;C:\Users\19682\Desktop\123&#x27;, x)))</span><br><span class="line">for i in dir_list:</span><br><span class="line">    print(chr(int(i.split(&#x27;.&#x27;)[0][1:])),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211222703931.png" alt="image-20221211222703931"></p><p>继续凯撒爆破一下</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211222728304.png" alt="image-20221211222728304"></p><p>解密得到flag</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211222956886.png" alt="image-20221211222956886"></p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211223052426.png" alt="image-20221211223052426"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;比赛介绍：&lt;br&gt;本次竞赛旨在通过以赛促学、以赛促进的竞赛提升方式，面向网络安全从业者、兴趣爱好者、在校学生，通过竞技比武，检验参赛人员的网络安全综合能力，培养和选拔一批高素质网络安全人才，进而营造良好的网络安全知识学习和技能提升氛围，吸引更多高校学生投身网络强国建设事业，</summary>
      
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="比赛" scheme="http://example.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>2022NCTF</title>
    <link href="http://example.com/2022/12/05/2022nctf/"/>
    <id>http://example.com/2022/12/05/2022nctf/</id>
    <published>2022-12-04T16:00:00.000Z</published>
    <updated>2022-12-11T15:43:41.259Z</updated>
    
    <content type="html"><![CDATA[<p>比赛介绍</p><p>本届NCTF是由X1cT34m战队组织，将采用在线网络安全夺旗挑战赛的形式，面向全球开放.</p><p>比赛总结</p><p>在比赛时间内没有做出几道来，几乎都是有思路可以做几步但又做不全得不到最后的flag，很难受，还是太菜</p><h2 id="MISC"><a href="#MISC" class="headerlink" title="MISC"></a>MISC</h2><h3 id="只因因"><a href="#只因因" class="headerlink" title="只因因"></a>只因因</h3><p>根据题目描述去该<a href="https://www.ncbi.nlm.nih.gov/">网站</a>搜索即可，搜索结果的第一个md5值即为flag</p><h3 id="Signin"><a href="#Signin" class="headerlink" title="Signin"></a>Signin</h3><p>一开始没理解秘籍的含义，bing上搜索并没有相关暗示，换百度可以发现是魂斗罗的秘籍</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221210125043142.png"></p><p>直接肉眼ocr</p><h3 id="qrssssssss（复现）"><a href="#qrssssssss（复现）" class="headerlink" title="qrssssssss（复现）"></a>qrssssssss（复现）</h3><p>二维码相关的题目，是得好好学习一下二维码有关知识了</p><p>附件给了一堆二维码,批量扫完再字频统计，应该是将flag打乱顺序乱序16次</p><p>这里的考点其实二维码的纠错码，算上nctf{}加上括号内的26位，正好照应LMQH的32个纠错等级</p><p>通过CQR再结合字频统计的字符其实是可以手撸出来的</p><p>这里先放上作者的官解,具体的学习放在其他博客了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">from pyzbar.pyzbar import decode</span><br><span class="line">import os</span><br><span class="line">​</span><br><span class="line">def maskanalysis(img):</span><br><span class="line">    sign=&#x27;&#x27;</span><br><span class="line">    for ii in range(510,670,20):</span><br><span class="line">        pi=img.getpixel((ii,170))</span><br><span class="line">        if(pi==0):</span><br><span class="line">            sign+=&#x27;1&#x27;</span><br><span class="line">        if(pi==255):</span><br><span class="line">            sign+=&#x27;0&#x27;</span><br><span class="line">    return sign</span><br><span class="line">​</span><br><span class="line">def scanqr(img):</span><br><span class="line">    decocdeQR = decode(img)</span><br><span class="line">    return decocdeQR[0].data.decode(&#x27;ascii&#x27;)</span><br><span class="line">​</span><br><span class="line">qrlist=os.listdir(r&quot;C:\Users\16334\Desktop\qrssssssss_revenge&quot;)</span><br><span class="line">flag=[0]*32</span><br><span class="line">masklist=[&#x27;11000100&#x27;,&#x27;11110011&#x27;,&#x27;10101010&#x27;,&#x27;10011101&#x27;,&#x27;00101111&#x27;,&#x27;00011000&#x27;,&#x27;01000001&#x27;,&#x27;01110110&#x27;,&#x27;00010010&#x27;,&#x27;00100101&#x27;,&#x27;01111100&#x27;,&#x27;01001011&#x27;,&#x27;11111001&#x27;,&#x27;11001110&#x27;,&#x27;10010111&#x27;,&#x27;10100000&#x27;,&#x27;01011111&#x27;,&#x27;01101000&#x27;,&#x27;00110001&#x27;,&#x27;00000110&#x27;,&#x27;10110100&#x27;,&#x27;10000011&#x27;,&#x27;11011010&#x27;,&#x27;11101101&#x27;,&#x27;10001001&#x27;,&#x27;10111110&#x27;,&#x27;11100111&#x27;,&#x27;11010000&#x27;,&#x27;01100010&#x27;,&#x27;01010101&#x27;,&#x27;00001100&#x27;,&#x27;00111011&#x27;]</span><br><span class="line">for i in qrlist:</span><br><span class="line">    img=Image.open(r&quot;C:\Users\16334\Desktop\qrssssssss_revenge\&#123;&#125;&quot;.format(i))</span><br><span class="line">    qrmask=maskanalysis(img)</span><br><span class="line">    for j in range(32):</span><br><span class="line">        if(masklist[j]==qrmask):</span><br><span class="line">            flag[j]=scanqr(img)</span><br><span class="line">​</span><br><span class="line">print(&#x27;&#x27;.join(flag))</span><br></pre></td></tr></table></figure><h3 id="炉边聚会（复现）"><a href="#炉边聚会（复现）" class="headerlink" title="炉边聚会（复现）"></a>炉边聚会（复现）</h3><p>不是炉石玩家，但好像网上是有不止一篇对炉石<a href="https://zhuanlan.zhihu.com/p/142113610">卡牌代码</a>的描述的，只能说信息检索能力不足。。。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fflag=[&#x27;10001100&#x27;,&#x27;00000110&#x27;,&#x27;10011110&#x27;,&#x27;00000101&#x27;,&#x27;11001000&#x27;,&#x27;00000110&#x27;,&#x27;10111100&#x27;,&#x27;00000101&#x27;,&#x27;11001110&#x27;,&#x27;00001001&#x27;,&#x27;11010000&#x27;,&#x27;00000101&#x27;,&#x27;11110010&#x27;,&#x27;00000111&#x27;,&#x27;11001010&#x27;,&#x27;00000111&#x27;,&#x27;11110100&#x27;,&#x27;00001000&#x27;,&#x27;10001000&#x27;,&#x27;00001001&#x27;,&#x27;10010000&#x27;,&#x27;00001000&#x27;,&#x27;10111110&#x27;,&#x27;00000110&#x27;,&#x27;10001000&#x27;,&#x27;00001001&#x27;,&#x27;11010110&#x27;,&#x27;00001000&#x27;,&#x27;11001100&#x27;,&#x27;00001000&#x27;,&#x27;11110010&#x27;,&#x27;00000111&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;10011110&#x27;,&#x27;00000101&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;11101000&#x27;,&#x27;00000111&#x27;,&#x27;11110010&#x27;,&#x27;00000111&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;10111110&#x27;,&#x27;00000110&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;10111100&#x27;,&#x27;00000101&#x27;,&#x27;10010010&#x27;,&#x27;00001001&#x27;,&#x27;11001100&#x27;,&#x27;00001000&#x27;,&#x27;11001100&#x27;,&#x27;00001000&#x27;,&#x27;11111010&#x27;,&#x27;00000110&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;11110100&#x27;,&#x27;00001000&#x27;,&#x27;10011010&#x27;,&#x27;00001000&#x27;,&#x27;10111010&#x27;,&#x27;00000100&#x27;,&#x27;10010000&#x27;,&#x27;00001000&#x27;,&#x27;10001000&#x27;,&#x27;00001001&#x27;,&#x27;11110110&#x27;,&#x27;00000100&#x27;,&#x27;11100010&#x27;,&#x27;00001001&#x27;,&#x27;00000000&#x27;,&#x27;00000000&#x27;]</span><br><span class="line">for i in range(40):</span><br><span class="line">    flag=fflag[2*i+1]+fflag[2*i][1:-1]+fflag[2*i][-1]</span><br><span class="line">    fla=int(flag,2)</span><br><span class="line">    fl=fla//10</span><br><span class="line">    print(chr(fl),end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><h3 id="zystego（复现）"><a href="#zystego（复现）" class="headerlink" title="zystego（复现）"></a>zystego（复现）</h3><p>图片末尾提取压缩包爆破</p><p>得到一个假flag和私钥文件</p><p>打开ps观察图片发现右侧通道异常</p><p>提取右三列像素点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">w=515</span><br><span class="line">h=512</span><br><span class="line">img=Image.open(r&quot;C:\Users\19682\Desktop\fd.png&quot;)</span><br><span class="line">a=[]</span><br><span class="line">for i in range(h):</span><br><span class="line">    for j in range(w-3,w):</span><br><span class="line">        pixel=img.getpixel((j,i))</span><br><span class="line">        for k in range(3):</span><br><span class="line">            a.append(pixel[k])</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211230637767.png" alt="image-20221211230637767"></p><p>都是0或5结尾的，考虑二进制0和1，写脚本转一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">w=515</span><br><span class="line">h=512</span><br><span class="line">img=Image.open(r&quot;C:\Users\19682\Desktop\fd.png&quot;)</span><br><span class="line">a=[]</span><br><span class="line">for i in range(h):</span><br><span class="line">    for j in range(w-3,w):</span><br><span class="line">        pixel=img.getpixel((j,i))</span><br><span class="line">        for k in range(3):</span><br><span class="line">            a.append(pixel[k])</span><br><span class="line"></span><br><span class="line">for i in a:</span><br><span class="line">    if i%10==0:</span><br><span class="line">        print(0,end=&#x27;&#x27;)</span><br><span class="line">    elif i%10==5:</span><br><span class="line">        print(1,end=&#x27;&#x27;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>cyberchef转一下二进制：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211231119451.png" alt="image-20221211231119451"></p><p>得到脚本和一串密码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import secret</span><br><span class="line"></span><br><span class="line">丁真 = np.float32(cv2.imread(r&quot;C:\Users\16334\Desktop\fadian.png&quot;, 1))</span><br><span class="line"></span><br><span class="line">for i in range(64):</span><br><span class="line">for j in range(64):</span><br><span class="line">芝士 = randint(0,2)</span><br><span class="line">小马珍珠 = 丁真[:, :, 芝士]</span><br><span class="line">雪豹 = cv2.dct(小马珍珠[8*i:8*i+8, 8*j:8*j+8])</span><br><span class="line">if(secret[i*64+j] == &#x27;1&#x27;):</span><br><span class="line">雪豹[7,7] = 20</span><br><span class="line">elif(secret[i*64+j] == &#x27;0&#x27;):</span><br><span class="line">雪豹[7,7] = -20</span><br><span class="line">小马珍珠[8*i:8*i+8, 8*j:8*j+8] = cv2.idct(雪豹)</span><br><span class="line">丁真[:, :, 芝士] = 小马珍珠</span><br><span class="line"></span><br><span class="line">cv2.imwrite(r&quot;C:\Users\16334\Desktop\fd.png&quot;, 丁真)</span><br><span class="line">#a gift for you : %$#%$#jhgasdfg76342t........................</span><br></pre></td></tr></table></figure><p>这里给出的是一个加密脚本</p><p>把原图分成了许多8x8的块，然后在这个块上随机选择rgb通道中的一个进行dct变换（离散余弦变换），然后根据secret.txt里是1还是0来改变dct矩阵右下角的值，然后合并进原图，最后保存</p><p>解密脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import cv2</span><br><span class="line">img = np.float32(cv2.imread(r&quot;C:\Users\19682\Desktop\fd.png&quot;, 1))</span><br><span class="line">for i in range(64):</span><br><span class="line">    for j in range(64):</span><br><span class="line">        for k in range(3):</span><br><span class="line">            imgg=img[:, :, k]</span><br><span class="line">            dctt = cv2.dct(imgg[8*i:8*i+8, 8*j:8*j+8])</span><br><span class="line">            if (dctt[7,7] &gt;= 10):</span><br><span class="line">                print(&#x27;1&#x27;,end=&#x27;&#x27;)</span><br><span class="line">            elif(dctt[7,7] &lt; -10):</span><br><span class="line">                print(&#x27;0&#x27;,end=&#x27;&#x27;)</span><br></pre></td></tr></table></figure><p>看了官解，dct会产生一些损失，因此与10进行比较</p><p>导入私钥结合之前的密码，得到flag</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211234340522.png" alt="image-20221211234340522"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;比赛介绍&lt;/p&gt;
&lt;p&gt;本届NCTF是由X1cT34m战队组织，将采用在线网络安全夺旗挑战赛的形式，面向全球开放.&lt;/p&gt;
&lt;p&gt;比赛总结&lt;/p&gt;
&lt;p&gt;在比赛时间内没有做出几道来，几乎都是有思路可以做几步但又做不全得不到最后的flag，很难受，还是太菜&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="比赛" scheme="http://example.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>2022安洵杯</title>
    <link href="http://example.com/2022/11/27/2022axbctf/"/>
    <id>http://example.com/2022/11/27/2022axbctf/</id>
    <published>2022-11-26T16:00:00.000Z</published>
    <updated>2022-12-07T14:37:55.581Z</updated>
    
    <content type="html"><![CDATA[<p>回家路上打的比赛，高铁站坐牢捏</p><h2 id="Crypto"><a href="#Crypto" class="headerlink" title="Crypto"></a>Crypto</h2><h3 id="Cry1"><a href="#Cry1" class="headerlink" title="Cry1"></a>Cry1</h3><p>签到题，对四位数进行爆破即可</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">from hashlib import *</span><br><span class="line">b=&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;</span><br><span class="line">a=&#x27;qD0FP6G2kS8QcpG7&#x27;</span><br><span class="line">for i in b:</span><br><span class="line">    for j in b:</span><br><span class="line">        for m in b:</span><br><span class="line">            for n in b:</span><br><span class="line">                c=str(i)+str(j)+str(m)+str(n)+a</span><br><span class="line">                d=sha256(c.encode(&#x27;utf-8&#x27;)).hexdigest()</span><br><span class="line">                if d==&#x27;86455b01fd7022f72ff93db1e9b2760cea520588db534cdeb3febb2d82a56e1e&#x27;:</span><br><span class="line">                    print(c)</span><br></pre></td></tr></table></figure><p>不过拿flag还是比较看脸的qaq,试了无数次</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128220814803.png" alt="image-20221128220814803"></p><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="GumpKing"><a href="#GumpKing" class="headerlink" title="GumpKing"></a>GumpKing</h3><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128220939908.png" alt="image-20221128220939908"></p><p>基于虚幻引擎的小游戏</p><p>给的文件没什么太大帮助，一开始还以为是修改配置文件去拿flag</p><p>这里使用作弊工具（cheat engine）去修改分数值</p><p>游戏全屏不太好使用ce进行扫描,alt+enter切换为窗口模式</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128221326696.png" alt="image-20221128221326696"></p><p>思路：</p><p>游戏开始前即分数为零时对0进行扫描，分数发生变化时对当前分数进行再次扫描，直到确定记录分数的地址，另开一局对该地址的值进行更改即可</p><p>经过多次尝试终于确定了记录分数的地址：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128221901636.png" alt="image-20221128221901636"></p><p>修改其初始值</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128221940124.png" alt="image-20221128221940124"></p><p>得到答案</p><h3 id="little-thief"><a href="#little-thief" class="headerlink" title="little_thief"></a>little_thief</h3><p>流量包分析</p><p>常规操作，导出http流查看是否存在有用信息：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128222100705.png" alt="image-20221128222100705"></p><p>好，导出</p><p>有密码，找</p><p>追踪tcp流逐个分析</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128222245109.png" alt="image-20221128222245109"></p><p>拉到最上面可以发现是登录信息</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128222337227.png" alt="image-20221128222337227"></p><p>以游客身份登陆的信息，没啥用，再找</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128222409363.png" alt="image-20221128222409363"></p><p>一眼jwt</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128222443977.png" alt="image-20221128222443977"></p><p>好，解一下</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128222522970.png" alt="image-20221128222522970"></p><p>找到压缩包密码了</p><p>打开flag.html，爆搜没有搜到flag,应该是隐写</p><p>使用wbStego4.3open进行解密，没有密钥</p><p>得</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128222843144.png" alt="image-20221128222843144"></p><h3 id="Redcoast"><a href="#Redcoast" class="headerlink" title="Redcoast"></a>Redcoast</h3><p>一堆二进制，转为16进制保存，得到压缩包</p><p>将压缩包里的图片按25x25的大小进行排列，得到一个二维码</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207221705935.png" alt="image-20221207221705935"></p><p>exp1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import binascii</span><br><span class="line">import base64</span><br><span class="line"></span><br><span class="line">a=Image.new(&#x27;RGB&#x27;,(2500,2500),&#x27;white&#x27;)</span><br><span class="line">n=0</span><br><span class="line">for i in range(25):</span><br><span class="line">    for j in range(25):</span><br><span class="line">        b=Image.open(f&#x27;./pic/&#123;n&#125;.png&#x27;)</span><br><span class="line">        a.paste(b,(100*j,100*i))</span><br><span class="line">        n+=1</span><br><span class="line">a.save(&#x27;6.png&#x27;)</span><br></pre></td></tr></table></figure><p>扫描，得到压缩包密码：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207221758034.png" alt="image-20221207221758034"></p><p>打开里面还是一堆数字+字母</p><p>cyberchef:</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207214408846.png" alt="image-20221207214408846"></p><p>是一张图片，但是存在许多混乱的像素带：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207221939223.png" alt="image-20221207221939223"></p><p>用stegsolve或者写脚本将每一个像素点的rgb提取并转为ascii</p><p>exp2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">img = Image.open(r&#x27;C:\Users\19682\Desktop\3.png&#x27;)</span><br><span class="line">pixel =[]</span><br><span class="line">imgSize = img.size</span><br><span class="line">x, y = imgSize[0], imgSize[1]  # (x1200, y750)</span><br><span class="line">for i in range(y):</span><br><span class="line">    for j in range(x):</span><br><span class="line">        pixel.append(img.getpixel((j, i)))</span><br><span class="line">message = &#x27;&#x27;</span><br><span class="line">for i in pixel:</span><br><span class="line">    for j in i:</span><br><span class="line">        message += chr(j)</span><br><span class="line">with open(&#x27;flag.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f:</span><br><span class="line">        f.write(message)</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207221404264.png" alt="image-20221207221404264"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回家路上打的比赛，高铁站坐牢捏&lt;/p&gt;
&lt;h2 id=&quot;Crypto&quot;&gt;&lt;a href=&quot;#Crypto&quot; class=&quot;headerlink&quot; title=&quot;Crypto&quot;&gt;&lt;/a&gt;Crypto&lt;/h2&gt;&lt;h3 id=&quot;Cry1&quot;&gt;&lt;a href=&quot;#Cry1&quot; clas</summary>
      
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="比赛" scheme="http://example.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>DASCTF-month11</title>
    <link href="http://example.com/2022/11/27/DAS11/"/>
    <id>http://example.com/2022/11/27/DAS11/</id>
    <published>2022-11-26T16:00:00.000Z</published>
    <updated>2022-12-07T12:48:52.002Z</updated>
    
    <content type="html"><![CDATA[<h2 id="七仙女下凡"><a href="#七仙女下凡" class="headerlink" title="七仙女下凡"></a>七仙女下凡</h2><p>附件给了6张包含内容相同的图片</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128224912835.png" alt="image-20221128224912835"></p><p>对比观察可发现几张图片宽高之间存在一定的比例关系</p><p>尝试使用stegsovle中的image combiner模块进行组合</p><p>image combiner中存在多种组合方式（包括异或、或、与等），鉴于本题宽高的特殊比例，选择其中的水平交错（Vertical interlace）与垂直交错（Horizontal interlace）</p><p>交错存在以下顺序：</p><p>  先1和2拼，垂直交错增加宽度，拼出来图片的再和3拼进行水平交错加高，再和4拼，加宽，再和5，加高，和6，加宽，最后和7，加高</p><p>导出7张图片合并完的最终结果，打开，观察颜色通道：</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128215009020.png" alt="image-20221128215009020"></p><p>red 0处存在明显异常，使用数据提取，rgb均选择最低位</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128215425200.png" alt="image-20221128215425200"></p><p>根据16进制，存在jpg文件，导出改后缀</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128215515278.png" alt="image-20221128215515278"></p><h2 id="EzUSB"><a href="#EzUSB" class="headerlink" title="EzUSB"></a>EzUSB</h2><p>这道题，根据后面的flag应该考查的是对于ntfs格式的usb硬盘的dbr分区恢复（事实上也确实是，因为观察dbr扇区可发现是全空的</p><p>但选择取证大师直接嗦</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128215739910.png" alt="image-20221128215739910"></p><p>拉到取证大师直接深度恢复可发现题目中说的机密文件的压缩包</p><p>导出，打开提示文件格式错误</p><p>使用winhex查看</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128215902208.png" alt="image-20221128215902208"></p><p>说实话，第一直觉，缺文件头，但观察主体也不像个zip文件的16进制格式</p><p>后来发现，是将zip文件的16进制进行了倒序</p><p>逆过来，单独保存，打开</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128220122458.png" alt="image-20221128220122458"></p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128220131301.png" alt="image-20221128220131301"></p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221128220150263.png" alt="image-20221128220150263"></p><p>这里放上皓文学长手修usb的dbr扇区的<a href="https://www.cnblogs.com/zhwer/p/15321534.html">链接</a> Orz</p><h2 id="Dink-Kirby-PC（复现）"><a href="#Dink-Kirby-PC（复现）" class="headerlink" title="Dink Kirby PC（复现）"></a>Dink Kirby PC（复现）</h2><p>与内存取证有关</p><p>vol分析一下内存镜像</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207184329466.png" alt="image-20221207184329466"></p><p>导出notepad.exe的进程</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207185235901.png" alt="image-20221207185235901"></p><p>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">volatility_2.6_win64_standalone -f 66.raw --profile=Win7SP1x64 memdump -p 3860 -D ./</span><br></pre></td></tr></table></figure><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207202327501.png" alt="image-20221207202327501"></p><p>发现一个带锁的压缩包，结合passkit提取的电脑开机密码可以解开</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207203429489.png" alt="image-20221207203429489"></p><p>这里的perl命令不是太会，但是大体上的意思应该是对$_PASSWORD进行了加密，我们可以尝试手撸爆破出来，当然也可以写脚本</p><p>TeamGipsy的exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import string</span><br><span class="line">x=&#x27;878189096364096066836664&#x27;</span><br><span class="line">string1=&#x27;0123456789&#x27;</span><br><span class="line">string2=&#x27;8195376024&#x27;</span><br><span class="line">string3=string.digits+string.ascii_lowercase</span><br><span class="line">string4=string.ascii_lowercase+string.digits</span><br><span class="line">x=x.translate(str.maketrans(string2,string1))</span><br><span class="line">flag=&#x27;&#x27;</span><br><span class="line">for i in range(0,len(x),2):</span><br><span class="line">    flag+=chr(int(x[i:i+2])^0x31)</span><br><span class="line">flag=flag.translate(str.maketrans(string3,string4))</span><br><span class="line">print(flag)</span><br><span class="line">#ead803812f23</span><br></pre></td></tr></table></figure><p>得到了aes的密钥，那么aes呢？</p><p>应该还在内存里，找吧</p><p>经过aes加密的字符串都以U2Fsd开头，我们可以直接搜关键字</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207204353939.png" alt="image-20221207204353939"></p><p>理论上取证大师的原始数据应该也可以搜索到</p><p>现在我们解密</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207204623577.png" alt="image-20221207204623577"></p><p>拿这个密码去解密附件给的encrypt.crypto文件</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207204817309.png" alt="image-20221207204817309"></p><p>ok了</p><p><img src="https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221207204837137.png" alt="image-20221207204837137"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;七仙女下凡&quot;&gt;&lt;a href=&quot;#七仙女下凡&quot; class=&quot;headerlink&quot; title=&quot;七仙女下凡&quot;&gt;&lt;/a&gt;七仙女下凡&lt;/h2&gt;&lt;p&gt;附件给了6张包含内容相同的图片&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://picture-131283645</summary>
      
    
    
    
    <category term="ctf" scheme="http://example.com/categories/ctf/"/>
    
    
    <category term="比赛" scheme="http://example.com/tags/%E6%AF%94%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>迁移通知</title>
    <link href="http://example.com/2022/11/25/test/"/>
    <id>http://example.com/2022/11/25/test/</id>
    <published>2022-11-24T16:00:00.000Z</published>
    <updated>2022-11-30T05:06:55.101Z</updated>
    
    <content type="html"><![CDATA[<p>从最开始接触网安时使用的<a href="https://blog.csdn.net/weixin_54448259?spm=1000.2115.3001.5343">csdn</a>,到后来利用腾讯云服务器和wordpress一步一步搭建的<a href="https://www.perfectcqf.xyz/">博客</a>，再到最后的<a href="https://www.cnblogs.com/perfectcqf/">博客园</a></p><p>。最终还是选择了hexo+github搭建的静态博客网站。</p><p>csdn作为国内体量最大的IT学习平台，其资源量是巨大的，加上其较为完善的移动端app,有着不言而喻的便利性，无奈被其纷杂的广告劝退，但是用来搜集和学习知识还是不错的。</p><p>自己通过租用服务器并利用wordpress搭建的静态服务器，让自己对网站的结构有了更深刻的认识，然而不是每个大学牲都支付得起服务器的租金，加之服务器性能的原因，网站渲染起来很慢，最终没有再维护下去。</p><p>博客园相较于前两者，没有广告，加载起来也很快，还支持自定义js，可以满足博客的大部分需求，但是对我个人而言，还是更加青睐于一个没有后台的静态博客网站，因此最终选择了部署在github上的hexo。</p><p>目前还没有完全把hexo玩懂，愿我和我的小网站可以一起进步，一次成长吧！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从最开始接触网安时使用的&lt;a href=&quot;https://blog.csdn.net/weixin_54448259?spm=1000.2115.3001.5343&quot;&gt;csdn&lt;/a&gt;,到后来利用腾讯云服务器和wordpress一步一步搭建的&lt;a href=&quot;https:/</summary>
      
    
    
    
    <category term="随手记" scheme="http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>测试专用</title>
    <link href="http://example.com/2022/01/01/hello-world/"/>
    <id>http://example.com/2022/01/01/hello-world/</id>
    <published>2021-12-31T16:00:00.000Z</published>
    <updated>2022-12-04T13:57:57.595Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="这都猜不对吗，老铁" data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="97dfd405be5248bf84484f233286366f0deca740c38f1bc872ed9a8f375a0b5f">5808c6cbf3ac08533f2dffaad5e129c17f52eaf63b1782bd17f13b48f7828ca76201e863c456d0254e45eed7a68822d66a318c01a4bd2b0909ec15ab16681924c046df778cc425445f27d5f7f1da2e6c66547b485d907020135156f7de07825ecf2d8c890bdbc7b7c6b81aff4a4f32ff0926d330491d4df5b654addf83e9bb953baea2b11681ac4ace028c318ce8ba82d0b898918838b7af58facac333338b0deb4e413e26f99795d4c0a473b15798a1a727139efc2b06ae5018649f95af457024204e51c587d836cfea17b9a09a4ef40649276005831df8ce1a6b104fd9074e82e9d9ab17a71752921f517010ca24b11c4e9fe920b5b9629f7afde891389d0fde127ce4c6fe0e010dec5d21398961e7527f59a285b46bf80e39d178e4fcc555bc52994c1c67cf1436ee379c5273e6f4631499308ec72d008200f83a01d745a31ee67dc8d2d018977eb179df03041add760d93350a39920b15cb3b852f352b429e1c0a92e8b42a7414b286c8dfb3e519a71af20b7585aba92122e18d0d977cffe03aa4e192f068992c4e5ae25fcd85e32973a257eae0d5a626f38261e6024a28264e7841013e31c070b0a023a838e5e25d6b082730e7b4966b0f7b82a14b519fa11d6b800f0884a92b9793becf4b9163be4040695a61164f0f1b18dbb4e0157f734b7cef192d7743d8093633f7fa7b81ccb4cb32894b189d9dd9ddcf95dc839fe5a9b5c51740579d81892d2837cec6cb63b84207a0d6ecf025f35b548e96497208ad2f6182a89795d45abc2c8913040569afb488eb549179c1b36c8858931c47953a3b6399648d9ff06714586a720f2d54b6b681fca55d54cdcc746dcc9404a1b0629c4506969f7c7c5bda3a595c07ef5f18e9fb24862041cec2b584cbea4d343bb35b79530bf5b48760bf331ae83a35e81cceda82470a10079e25e2c17fe60f7d499cd51b5e56800fbb7862ccd1e50bb90cbbe9230431724b55f8edffb5c9a264ed12d64a6f13dd84f93ce6f1b1713becf02ea778b86f2268baecf617c703c3466b0126a237763babd1b0cb96fc9d1d0dd805eaa363bed934fd140a1d79ce286b20354b02b3847f5fb66f2eed8184cd8ddf12dc61f4cc25a328359040f6784f4a5f35c59efbc415fe172d057dafc7c41cd99215fd0eb8a723d17d6259bdd646a25720c60e6835cd41e77d09eb3da0c3aa3e9eacd0b385c19d6c7932d75caf9d4829fc3ef8478433d50bc335a47527f42aa4a8c0b7296dfb3f035be7a5a098e80b1790d6fd3d43bb7d57778d9d94091596f7c20077e4ffc77f92f8d349a07b7bea4912c1df7484516918049680892911e9c855026839832fae1ff1102316aa04b9f6e63acf0f0bcc28aa2b2f2be301c1866c1c8db9a0d91b436752c67601f4f809a17d0db18197c9a28e933b27488fe8f37fe9b97419619b1620c9694fee16a4bee0f836f825789f76215d056de834b4d43ffc11097967d9deadd853e6abe12d764d7a6723832d3a61cdf4901d1141dcd5e60db28fcccbee56197216d5f7dcc8ceb2bcf19162411e00c6a06bdaf0c2c401bb569a472da7faa790803037c3c6667804d712982a489188375a51255d679ac5cf30101681ab944261e14c4ce27669e8aa94276099aa5b6e2189f4c5cd499bf3f775fdbc265265e827de794307c5a855e189ef9bfa8de9b6eb5c2f5ad1b22ff377882061d6ca017a082725cd3451e4aad26dc92949b95d6ccedb13b47a0c3816af597b9ac2d35f9f725336d9afe2cb126c0db7b32d1382b2b9b406025bd3e99470b7280e96ef043955a0dc0dd9ff6e89f790aec57a12ec524a7208394058c829bbef2a7738e8114c17f21311c6e1bcad4637e0eb2566c15257689cfb8b60a67ed779bb26e80fb8663f1f9f84197c642e5f07453f862e05d23cd6a1265d1c6265318261d6a655081ca31e974db6c2ac05f42604954a4dfe1d04b5156ded8c507eaf22399b5083bf2a588d430988c90182f9e3eda1eeb49d12e64c18aae6044adbe561c7f4a42d30f5bc057c68315e87d596bcc99d9e0f19c7fb09832c981fd059fa062671497a33728ac112c05075da68e9a5f58df7ee4f2038d7169eba32d22bb1ec74675cf8c727d9692ce8e38761b8381f5aeb0bc1e7269253c603892d9576284cad273c0b962eb7e4d303dd5f140b59ee00b259b1f9485fae5e5e8e4fdd51863c83c3e1af04e533a9c63e47acb8a0c4d5dc44f1325828e0c706f3b008781e03b6d0475f553d59344d0b0a17d389e524abaa7c2d9ed694920b2ee34291e573abc825b1ed53d8306646a1a26fa9132c9a889aab3a5bbb7dcd21674b2ff542ef6ceac452d45850d41ff62a8acd803585cee473386b7c63cca8705cf10bb65c0a48854eb64ad16c0b598b35c0a748bdeb2f057e0ed8bd90926bc6f573e877d938a5b50e1f5564d3053eeeda57add5d7e3eecf12276b90e393e4b284a59e048355fb2e6a1e69e7e9ad2b41fa766763afc81b9de597bc221ef5c6ebbf6eba4d591449ebe20b06262cefbc8e71e4a77f00e032344294da07274abc5590ec0fba22e3fc3f219e8b850e797b1a5e9ce4bc2c05f0dbead0bdd32a9841d35cdec63aa512ba8816bbdcf442b351e1a9149c67c262a309c851b8b916df93e89e5055629bc76cfb4a72a0e9b34f5ebc5aceeb9463bc1e15c825557ccf8d722bd376d79ce958dfdf95503f6ccb5050cb7c0dee4bfb898bd36e9818d2dec9fe779ec064c38897a6f541b06eefe1dbc8e9c02ba827b516c80688783bf75a7ecbcf5a7e36f18d410784483663b313b3ed9123cff4e5605fa419ef112d37d06b86185c1d061e22173b13cc2d9852c393af7c2609b6c5bb722acbf4d61723b4dcaee6a392e131b87589072770a787c086d89cfd0dd74bdff4f458441ccdfa6dc1d272c3b0b4ab5bb830e8bef35bd57151c01a45528b7abe53d8641601931d22090134334df28f56d8a6c8bd431df050c713827f145e001e1a053f0e08228317a20aa76670e7e3c1937cf965b378c1809e24e56f2d9135a01a98adf38acfd92478c3ff4684d8e9661c2d32b96b7dc0c6b7a37fa9c0d9f3fab2cb4b1871a0e504b78700811e69018ed69af04b45cbbec22a0d7efea5a59ffbd2d3199689b36179af6e8dc46e7e16dd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-up">      <input class="hbe hbe-input-field hbe-input-field-up" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-up" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-up">三位数字弱口令</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">加密测试</summary>
    
    
    
    
  </entry>
  
</feed>
