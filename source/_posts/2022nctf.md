---
title:  2022NCTF
categories: ctf
toc: true
date: 2022/12/5
tags: 比赛
---

比赛介绍

本届NCTF是由X1cT34m战队组织，将采用在线网络安全夺旗挑战赛的形式，面向全球开放.

比赛总结

在比赛时间内没有做出几道来，几乎都是有思路可以做几步但又做不全得不到最后的flag，很难受，还是太菜

## MISC

### 只因因

根据题目描述去该[网站](https://www.ncbi.nlm.nih.gov/)搜索即可，搜索结果的第一个md5值即为flag

### Signin

一开始没理解秘籍的含义，bing上搜索并没有相关暗示，换百度可以发现是魂斗罗的秘籍

![](https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221210125043142.png)

直接肉眼ocr

### qrssssssss（复现）

二维码相关的题目，是得好好学习一下二维码有关知识了

附件给了一堆二维码,批量扫完再字频统计，应该是将flag打乱顺序乱序16次

这里的考点其实二维码的纠错码，算上nctf{}加上括号内的26位，正好照应LMQH的32个纠错等级

通过CQR再结合字频统计的字符其实是可以手撸出来的

这里先放上作者的官解,具体的学习放在其他博客了：

```she
from PIL import Image
from pyzbar.pyzbar import decode
import os
​
def maskanalysis(img):
    sign=''
    for ii in range(510,670,20):
        pi=img.getpixel((ii,170))
        if(pi==0):
            sign+='1'
        if(pi==255):
            sign+='0'
    return sign
​
def scanqr(img):
    decocdeQR = decode(img)
    return decocdeQR[0].data.decode('ascii')
​
qrlist=os.listdir(r"C:\Users\16334\Desktop\qrssssssss_revenge")
flag=[0]*32
masklist=['11000100','11110011','10101010','10011101','00101111','00011000','01000001','01110110','00010010','00100101','01111100','01001011','11111001','11001110','10010111','10100000','01011111','01101000','00110001','00000110','10110100','10000011','11011010','11101101','10001001','10111110','11100111','11010000','01100010','01010101','00001100','00111011']
for i in qrlist:
    img=Image.open(r"C:\Users\16334\Desktop\qrssssssss_revenge\{}".format(i))
    qrmask=maskanalysis(img)
    for j in range(32):
        if(masklist[j]==qrmask):
            flag[j]=scanqr(img)
​
print(''.join(flag))
```

### 炉边聚会（复现）

不是炉石玩家，但好像网上是有不止一篇对炉石[卡牌代码](https://zhuanlan.zhihu.com/p/142113610)的描述的，只能说信息检索能力不足。。。

```she
fflag=['10001100','00000110','10011110','00000101','11001000','00000110','10111100','00000101','11001110','00001001','11010000','00000101','11110010','00000111','11001010','00000111','11110100','00001000','10001000','00001001','10010000','00001000','10111110','00000110','10001000','00001001','11010110','00001000','11001100','00001000','11110010','00000111','10110110','00000111','10011110','00000101','11100000','00000011','11101000','00000111','11110010','00000111','10110110','00000111','10111110','00000110','11100000','00000011','11100000','00000011','11100000','00000011','10110110','00000111','10111100','00000101','10010010','00001001','11001100','00001000','11001100','00001000','11111010','00000110','10110110','00000111','11110100','00001000','10011010','00001000','10111010','00000100','10010000','00001000','10001000','00001001','11110110','00000100','11100010','00001001','00000000','00000000']
for i in range(40):
    flag=fflag[2*i+1]+fflag[2*i][1:-1]+fflag[2*i][-1]
    fla=int(flag,2)
    fl=fla//10
    print(chr(fl),end='')
```


### zystego（复现）

图片末尾提取压缩包爆破

得到一个假flag和私钥文件

打开ps观察图片发现右侧通道异常

提取右三列像素点：

```she
from PIL import Image
w=515
h=512
img=Image.open(r"C:\Users\19682\Desktop\fd.png")
a=[]
for i in range(h):
    for j in range(w-3,w):
        pixel=img.getpixel((j,i))
        for k in range(3):
            a.append(pixel[k])
print(a)
```

![image-20221211230637767](https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211230637767.png)

都是0或5结尾的，考虑二进制0和1，写脚本转一下

```shell
from PIL import Image
w=515
h=512
img=Image.open(r"C:\Users\19682\Desktop\fd.png")
a=[]
for i in range(h):
    for j in range(w-3,w):
        pixel=img.getpixel((j,i))
        for k in range(3):
            a.append(pixel[k])

for i in a:
    if i%10==0:
        print(0,end='')
    elif i%10==5:
        print(1,end='')

```

cyberchef转一下二进制：

![image-20221211231119451](https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211231119451.png)

得到脚本和一串密码

```she
import secret

丁真 = np.float32(cv2.imread(r"C:\Users\16334\Desktop\fadian.png", 1))

for i in range(64):
	for j in range(64):
		芝士 = randint(0,2)
		小马珍珠 = 丁真[:, :, 芝士]
		雪豹 = cv2.dct(小马珍珠[8*i:8*i+8, 8*j:8*j+8])
		if(secret[i*64+j] == '1'):
			雪豹[7,7] = 20
		elif(secret[i*64+j] == '0'):
			雪豹[7,7] = -20
		小马珍珠[8*i:8*i+8, 8*j:8*j+8] = cv2.idct(雪豹)
		丁真[:, :, 芝士] = 小马珍珠

cv2.imwrite(r"C:\Users\16334\Desktop\fd.png", 丁真)
#a gift for you : %$#%$#jhgasdfg76342t........................
```

这里给出的是一个加密脚本

把原图分成了许多8x8的块，然后在这个块上随机选择rgb通道中的一个进行dct变换（离散余弦变换），然后根据secret.txt里是1还是0来改变dct矩阵右下角的值，然后合并进原图，最后保存

解密脚本：

```shell
import numpy as np
import cv2
img = np.float32(cv2.imread(r"C:\Users\19682\Desktop\fd.png", 1))
for i in range(64):
    for j in range(64):
        for k in range(3):
            imgg=img[:, :, k]
            dctt = cv2.dct(imgg[8*i:8*i+8, 8*j:8*j+8])
            if (dctt[7,7] >= 10):
                print('1',end='')
            elif(dctt[7,7] < -10):
                print('0',end='')
```

看了官解，dct会产生一些损失，因此与10进行比较

导入私钥结合之前的密码，得到flag

![image-20221211234340522](https://picture-1312836458.cos.ap-beijing.myqcloud.com/img/image-20221211234340522.png)