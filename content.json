{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"分类","date":"2022-11-25T09:21:06.352Z","updated":"2022-11-25T08:04:09.721Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"留言板","date":"2022-12-08T14:52:06.667Z","updated":"2022-12-08T14:52:06.667Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"这都被你发现了？ 留个言吧👇👇👇"},{"title":"友情链接","date":"2022-11-25T09:21:18.139Z","updated":"2022-11-25T08:04:09.722Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-11-25T08:04:09.722Z","updated":"2022-11-25T08:04:09.722Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ShowTime","slug":"ShowTime","date":"2022-12-11T16:00:00.000Z","updated":"2022-12-12T15:17:40.202Z","comments":true,"path":"2022/12/12/ShowTime/","link":"","permalink":"http://example.com/2022/12/12/ShowTime/","excerpt":"","text":"Tokeii师傅在i春秋上出的一道题，挺新奇的，记录一下 思路源于他的这篇博客 下载后的附件，名字都是base64编码的，写脚本改名 123456p=r&#x27;C:\\Users\\19682\\Desktop\\stego&#123;&#125;&#x27;.format(&#x27;\\\\&#x27;)for i in filelist: b=i[:-4] a=base64.b64decode(b) c=a.decode(&#x27;UTF-8&#x27;) d=os.rename(p+i,p+c+&#x27;.txt&#x27;) 提取每个文件修改时间戳的最后一位 1234567import osfor i in range(925): filename = r&quot;C:\\Users\\19682\\Desktop\\stego\\&#123;&#125;.txt&quot;.format(i) file_attr = os.stat(filename)#读取文件属性 create_time = str(file_attr.st_mtime)#获取修改时间 # print(create_time) print(int(create_time[9:10]),end=&#x27;&#x27;) 将数字转字符串 123from numlib import *a=1774674557824868457499061032120895601890679002715594296727500711025736399907449201395656994728720806964341210442762667972497818255944821704615312664370539310702290900650405564784263444957700019095984690444788205828883771674746086773438649406269794894162345496646835920006634655790770023591140601368298957582899939643842210521270729599027362038934484123582308984705653794101554567102555263227506545092094002357706759680210528515040207139078660910227189154726011658251525180920105580373673544062554076786313766549322038531510544996944293029774158028502472577209425526755227464619459049995527828690565067923263594211663575768777749797684020900044480050567580861721772084896501068329188549341576999149193729307442677823665245077311594986800407693715823937313065541334395357854650051549808442561638033762084503042808464197473992558178954715114984494063565778497512453063854507422273051449037068016131470694073345956605305655737661print (n2s(a)) 得到一串base64 拿到cyberchef解码保存为7z文件解压后打开即得flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"⎛⎝龙猫⎠⎞","slug":"Totoro","date":"2022-12-11T16:00:00.000Z","updated":"2022-12-12T15:17:43.541Z","comments":true,"path":"2022/12/12/Totoro/","link":"","permalink":"http://example.com/2022/12/12/Totoro/","excerpt":"","text":"lazzzaro师傅出的一道题 下载附件改后缀为.zip 解压出一张打不开的图片和带密码的压缩包 打不开的图片的16进制头与正常jpg比较后发现规律 0101修改为正常图片得到： 发现图片16进制尾部隐藏的信息，转两次hex得到： 得到压缩包密码并提示进行异或 起初以为是对key文件进行异或，并且key文件与2B异或完确实还能得到一张图片 后来发现相偏了，这里考查的并不是双图隐写 因为key文件导入到010保存后的大小是和totoro.jpg一样的，所以是用key直接和totoro.jpg逐字节异或 exp： 1234567891011121314f1=open(r&#x27;C:\\Users\\19682\\Desktop\\Totoro.jpg&#x27;,&#x27;rb&#x27;)f11=f1.read()f2=open(r&#x27;C:\\Users\\19682\\Desktop\\key&#x27;,&#x27;rb&#x27;)f22=f2.read()print(len(f11))print(len(f22))res=&#x27;&#x27;for i in range(len(f11)): res+=chr(f11[i]^f22[i])b=open(&#x27;1234&#x27;,&#x27;w&#x27;)b.write(res)f1.close()f2.close() 得到的文件导入010得： 在众多+号中存在一段特殊序列，包含+[&gt;&lt;-.]，即两个问号中间得部分 复制到brainfuck解密得到flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"2022RCTF","slug":"2022rctf","date":"2022-12-09T16:00:00.000Z","updated":"2022-12-14T14:46:01.936Z","comments":true,"path":"2022/12/10/2022rctf/","link":"","permalink":"http://example.com/2022/12/10/2022rctf/","excerpt":"","text":"坐牢坐牢坐牢orz ez_alientalien.bmp文件尾部存在压缩包解压密码 解压后文件查看文件头发现为可执行文件，运行后发现为pygame即pyexe 使用pyinstxtractor.py解包可得pyc文件 1python pyinstxtractor.py alien_invasion.exe 同路径下会出现的[xxx.exe]_extracted的文件夹里面就包含了主程序main，但不带任何后缀，我们要反编译的就是这个文件，其他的都是依赖库，如PYZ-extracted文件夹里的都是库文件（用于import）。 至于为什么该文件不是.pyc文件，应该是pyinstxtractor的一点不足，转换出来的主程序格式不对，因此还需要对其进行手动修复。这里了解下不同版本python下pyc文件头的结构： Python3.3以下的版本中，只有Magic Number和四位时间戳（共8字节）Python3.3到Python3.7（不包含3.7）版本中，只有Magic Number和八位时间戳 + 大小信息（共12字节）Python3.7及以上版本的编译后二进制文件中，头部除了四字节Magic Number，还有四个字节的空位和八个字节的时间戳 + 大小信息（共16字节），后者（指后12字节）对文件反编译没有影响，全部填充0即可 python Magic Number对照表 1234567891011121314151617181920212223242526enum PycMagic &#123; MAGIC_1_0 = 0x00999902, MAGIC_1_1 = 0x00999903, /* Also covers 1.2 */ MAGIC_1_3 = 0x0A0D2E89, MAGIC_1_4 = 0x0A0D1704, MAGIC_1_5 = 0x0A0D4E99, MAGIC_1_6 = 0x0A0DC4FC, MAGIC_2_0 = 0x0A0DC687, MAGIC_2_1 = 0x0A0DEB2A, MAGIC_2_2 = 0x0A0DED2D, MAGIC_2_3 = 0x0A0DF23B, MAGIC_2_4 = 0x0A0DF26D, MAGIC_2_5 = 0x0A0DF2B3, MAGIC_2_6 = 0x0A0DF2D1, MAGIC_2_7 = 0x0A0DF303, MAGIC_3_0 = 0x0A0D0C3A, MAGIC_3_1 = 0x0A0D0C4E, MAGIC_3_2 = 0x0A0D0C6C, MAGIC_3_3 = 0x0A0D0C9E, MAGIC_3_4 = 0x0A0D0CEE, MAGIC_3_5 = 0x0A0D0D16, MAGIC_3_5_3 = 0x0A0D0D17, MAGIC_3_6 = 0x0A0D0D33, MAGIC_3_7 = 0x0A0D0D42, MAGIC_3_8 = 0x0A0D0D55, MAGIC_3_9 = 0x0A0D0D61, &#125;; 这里即使解包出来的pyc也没办法直接逆 以上内容大致意思就是文件头格式不对（链接） 依照上面的规则修改如下： 拿第一行16个字节去修主函数即可成功逆向 逆完后面的步骤就比较简单了，主文件及其中引用到的库函数中均存在一个base64后的片段，解码后拼接即可。 ez_pvz逆向大佬都是ida梭的orz 我当时只用ce通了一关，一直想锁定阳光的基址（奈何失败qaq 做法： 第一关：搜100，种豌豆，搜0，确定阳光临时地址 第二关：开局搜150，几十个数，挨个改为0，前几个改完查看游戏就发现找到了双豌豆和樱桃炸弹的费用地址，修改为零即可 第三关：做法同第二关，找到费用地址后查看内存，可以发现动态变化的内存地址即cd的变化地址，其后面的一个字节也会随着前面的变化规律变化，观察一会发现会从01（满cd）递增到10（无cd），一直修改为10即可实现无cd","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"首届“天权信安&catf1ag”网络安全联合公开赛","slug":"catflag","date":"2022-12-08T16:00:00.000Z","updated":"2022-12-11T15:51:45.928Z","comments":true,"path":"2022/12/09/catflag/","link":"","permalink":"http://example.com/2022/12/09/catflag/","excerpt":"","text":"比赛介绍：本次竞赛旨在通过以赛促学、以赛促进的竞赛提升方式，面向网络安全从业者、兴趣爱好者、在校学生，通过竞技比武，检验参赛人员的网络安全综合能力，培养和选拔一批高素质网络安全人才，进而营造良好的网络安全知识学习和技能提升氛围，吸引更多高校学生投身网络强国建设事业，推动网络安全人才的培养，以及加快高校网络安全人才的储备，为国家网络安全建设添砖加瓦，为行业技术提升创新贡献自己的力量。 比赛总结： 赛题难度适中，自身仍有很大提升空间orz Crypto疑惑exp: 1234567# 题目介绍：我好&quot;疑惑&quot;啊# keys1 = welcome_to_nine-ak_match_is_so_easy_!@!# keys2 = 20 4 24 5 94 12 2 36 26 6 49 11 68 15 14 114 12 10 43 14 9 43 10 27 31 31 22 45 10 48 58 4 18 10 38 31 14 97 92a=[20,4,24,5,94,12,2,36,26,6,49,11,68,15,14,114,12,10,43,14,9,43,10,27,31,31,22,45,10,48,58,4,18,10,38,31,14,97,92]b=&#x27;welcome_to_nine-ak_match_is_so_easy_!@!&#x27;for i in range(len(b)): print(chr(ord(b[i])^a[i]),end=&#x27;&#x27;) catf1ag{nine-ak_match_is@very_easy_@&#x2F;!} easyrsaexp： 1234567from Crypto.Util.number import *e = 0x10001d=12344766091434434733173074189627377553017680360356962089159282442350343171988536143126785315325155784049041041740294461592715296364871912847202681353107182427067350160760722505537695351060872358780516757652343767211907987297081728669843916949983336698385141593880433674937737932158161117039734886760063825649623992179585362400642056715249145349214196969590250787495038347519927017407204272334005860911299915001920451629055970214564924913446260348649062607855669069184216149660211811217616624622378241195643396616228441026080441013816066477785035557421235574948446455413760957154157952685181318232685147981777529010093c=11665709552346194520404644475693304343544277312139717618599619856028953672850971126750357095315011211770308088484683204061365343120233905810281045824420833988717463919084545209896116273241788366262798828075566212041893949256528106615605492953529332060374278942243879658004499423676775019309335825331748319484916607746676069594715000075912334306124627379144493327297854542488373589404460931325101587726363963663368593838684601095345900109519178235587636259017532403848656471367893974805399463278536349688131608183835495334912159111202418065161491440462011639125641718883550113983387585871212805400726591849356527011578n=13717871972706962868710917190864395318380380788726354755874864666298971471295805029284299459288616488109296891203921497014120460143184810218680538647923519587681857800257311678203773339140281665350877914208278709865995451845445601706352659259559793431372688075659019308448963678380545045143583181131530985665822655263963917413080872997526445384954610888776917323156325542921415838122754036103689148810677276471252057077595104724365967333418002158480223657363936976281758713027828747277980907153645847605403914070601944617432177385048803228970693240587900504431163155958465431312258451026447435473865563581029300541109m=pow(c,d,n)print(long_to_bytes(m)) flag{3895dfda-67b1-11ed-b784-b07b2568d266} passwdexp: 1234567891011from hashlib import *a=&#x27;&#x27;for i in range(1,13): for j in range(1,32): for m in range(1,25): for n in range(1,61): c=&#x27;2022&#x27;+str(&quot;%02d&quot; % i)+&#x27;&#x27;+str(&quot;%02d&quot; % j)+&#x27;&#x27;+str(&quot;%02d&quot; % m)+&#x27;&#x27;+str(&quot;%02d&quot; % n)+&#x27;&#x27; d=sha256(c.encode(&#x27;utf-8&#x27;)).hexdigest() if d==&#x27;69d00d9bc39e01687abf84e98e27c889cf1442b53edba27d3235acbeb7b0ae95&#x27;: print(c) catf1ag{202211121750} Misc十位马将文件里的16进制放到cyberchef转hex再倒序，以zip格式保存 打开发现一对正方形图片 根据具有顺序的名字，考虑进行拼图 脚本： 123456789101112from PIL import Imageimport binasciiimport base64a=Image.new(&#x27;RGB&#x27;,(300,300),&#x27;white&#x27;)n=0for i in range(10): for j in range(10): b=Image.open(f&#x27;./WHAT_1S_FLAG/WHAT_1S_FLAG_&#123;n&#125;.png&#x27;) a.paste(b,(30*j,30*i)) n+=1a.save(&#x27;7.png&#x27;) 拼好的图片： 手动ps上两个定位符，到在线网站进行识别 flag{cbef4c93-5e9c-11ed-8205-666c80085daf} 简单隐写（复现）图片尾部存在rar压缩包，kali里面dd命令分离 压缩包加密 由于没有见过这种隐写，一直也没有写出来 考查jphide隐写 使用jphs无密码解密 主要也不清楚该隐写有什么特征，问群友说一个一个试，还是见得太少了orz 使用密码解压 凯撒密码： 阿sir（复现）以为相对拿手的电子取证来了，结果到快结束才找到能解这个零宽的网站orz 零宽解密: 取证大师挂载 发现桌面上的一张图片16进制末尾有东西 将megrez前面的字母和数字以及最后的’&#x3D;‘提取出来 得到 解一下base 缓存记录里可以看到缓存了两个百度网盘的文件 上面的密码解不开 后来发现是最后一个是大写字母I而不是小写字母l 有点脑洞有点坑。。。 给了图片和一些名字不同的压缩包，压缩包名在传递信息，结合图片名中的stego应该是lsb隐写 人为创的压缩包肯定存在创建的时间顺序 写脚本解一下名字： 12345import osfilelist = os.listdir(r&#x27;C:\\Users\\19682\\Desktop\\123&#x27;)dir_list = sorted(filelist,key=lambda x: os.path.getmtime(os.path.join(r&#x27;C:\\Users\\19682\\Desktop\\123&#x27;, x)))for i in dir_list: print(chr(int(i.split(&#x27;.&#x27;)[0][1:])),end=&#x27;&#x27;) 继续凯撒爆破一下 解密得到flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"2022NCTF","slug":"2022nctf","date":"2022-12-04T16:00:00.000Z","updated":"2022-12-11T15:43:41.259Z","comments":true,"path":"2022/12/05/2022nctf/","link":"","permalink":"http://example.com/2022/12/05/2022nctf/","excerpt":"","text":"比赛介绍 本届NCTF是由X1cT34m战队组织，将采用在线网络安全夺旗挑战赛的形式，面向全球开放. 比赛总结 在比赛时间内没有做出几道来，几乎都是有思路可以做几步但又做不全得不到最后的flag，很难受，还是太菜 MISC只因因根据题目描述去该网站搜索即可，搜索结果的第一个md5值即为flag Signin一开始没理解秘籍的含义，bing上搜索并没有相关暗示，换百度可以发现是魂斗罗的秘籍 直接肉眼ocr qrssssssss（复现）二维码相关的题目，是得好好学习一下二维码有关知识了 附件给了一堆二维码,批量扫完再字频统计，应该是将flag打乱顺序乱序16次 这里的考点其实二维码的纠错码，算上nctf{}加上括号内的26位，正好照应LMQH的32个纠错等级 通过CQR再结合字频统计的字符其实是可以手撸出来的 这里先放上作者的官解,具体的学习放在其他博客了： 1234567891011121314151617181920212223242526272829from PIL import Imagefrom pyzbar.pyzbar import decodeimport os​def maskanalysis(img): sign=&#x27;&#x27; for ii in range(510,670,20): pi=img.getpixel((ii,170)) if(pi==0): sign+=&#x27;1&#x27; if(pi==255): sign+=&#x27;0&#x27; return sign​def scanqr(img): decocdeQR = decode(img) return decocdeQR[0].data.decode(&#x27;ascii&#x27;)​qrlist=os.listdir(r&quot;C:\\Users\\16334\\Desktop\\qrssssssss_revenge&quot;)flag=[0]*32masklist=[&#x27;11000100&#x27;,&#x27;11110011&#x27;,&#x27;10101010&#x27;,&#x27;10011101&#x27;,&#x27;00101111&#x27;,&#x27;00011000&#x27;,&#x27;01000001&#x27;,&#x27;01110110&#x27;,&#x27;00010010&#x27;,&#x27;00100101&#x27;,&#x27;01111100&#x27;,&#x27;01001011&#x27;,&#x27;11111001&#x27;,&#x27;11001110&#x27;,&#x27;10010111&#x27;,&#x27;10100000&#x27;,&#x27;01011111&#x27;,&#x27;01101000&#x27;,&#x27;00110001&#x27;,&#x27;00000110&#x27;,&#x27;10110100&#x27;,&#x27;10000011&#x27;,&#x27;11011010&#x27;,&#x27;11101101&#x27;,&#x27;10001001&#x27;,&#x27;10111110&#x27;,&#x27;11100111&#x27;,&#x27;11010000&#x27;,&#x27;01100010&#x27;,&#x27;01010101&#x27;,&#x27;00001100&#x27;,&#x27;00111011&#x27;]for i in qrlist: img=Image.open(r&quot;C:\\Users\\16334\\Desktop\\qrssssssss_revenge\\&#123;&#125;&quot;.format(i)) qrmask=maskanalysis(img) for j in range(32): if(masklist[j]==qrmask): flag[j]=scanqr(img)​print(&#x27;&#x27;.join(flag)) 炉边聚会（复现）不是炉石玩家，但好像网上是有不止一篇对炉石卡牌代码的描述的，只能说信息检索能力不足。。。 123456fflag=[&#x27;10001100&#x27;,&#x27;00000110&#x27;,&#x27;10011110&#x27;,&#x27;00000101&#x27;,&#x27;11001000&#x27;,&#x27;00000110&#x27;,&#x27;10111100&#x27;,&#x27;00000101&#x27;,&#x27;11001110&#x27;,&#x27;00001001&#x27;,&#x27;11010000&#x27;,&#x27;00000101&#x27;,&#x27;11110010&#x27;,&#x27;00000111&#x27;,&#x27;11001010&#x27;,&#x27;00000111&#x27;,&#x27;11110100&#x27;,&#x27;00001000&#x27;,&#x27;10001000&#x27;,&#x27;00001001&#x27;,&#x27;10010000&#x27;,&#x27;00001000&#x27;,&#x27;10111110&#x27;,&#x27;00000110&#x27;,&#x27;10001000&#x27;,&#x27;00001001&#x27;,&#x27;11010110&#x27;,&#x27;00001000&#x27;,&#x27;11001100&#x27;,&#x27;00001000&#x27;,&#x27;11110010&#x27;,&#x27;00000111&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;10011110&#x27;,&#x27;00000101&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;11101000&#x27;,&#x27;00000111&#x27;,&#x27;11110010&#x27;,&#x27;00000111&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;10111110&#x27;,&#x27;00000110&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;10111100&#x27;,&#x27;00000101&#x27;,&#x27;10010010&#x27;,&#x27;00001001&#x27;,&#x27;11001100&#x27;,&#x27;00001000&#x27;,&#x27;11001100&#x27;,&#x27;00001000&#x27;,&#x27;11111010&#x27;,&#x27;00000110&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;11110100&#x27;,&#x27;00001000&#x27;,&#x27;10011010&#x27;,&#x27;00001000&#x27;,&#x27;10111010&#x27;,&#x27;00000100&#x27;,&#x27;10010000&#x27;,&#x27;00001000&#x27;,&#x27;10001000&#x27;,&#x27;00001001&#x27;,&#x27;11110110&#x27;,&#x27;00000100&#x27;,&#x27;11100010&#x27;,&#x27;00001001&#x27;,&#x27;00000000&#x27;,&#x27;00000000&#x27;]for i in range(40): flag=fflag[2*i+1]+fflag[2*i][1:-1]+fflag[2*i][-1] fla=int(flag,2) fl=fla//10 print(chr(fl),end=&#x27;&#x27;) zystego（复现）图片末尾提取压缩包爆破 得到一个假flag和私钥文件 打开ps观察图片发现右侧通道异常 提取右三列像素点： 1234567891011from PIL import Imagew=515h=512img=Image.open(r&quot;C:\\Users\\19682\\Desktop\\fd.png&quot;)a=[]for i in range(h): for j in range(w-3,w): pixel=img.getpixel((j,i)) for k in range(3): a.append(pixel[k])print(a) 都是0或5结尾的，考虑二进制0和1，写脚本转一下 1234567891011121314151617from PIL import Imagew=515h=512img=Image.open(r&quot;C:\\Users\\19682\\Desktop\\fd.png&quot;)a=[]for i in range(h): for j in range(w-3,w): pixel=img.getpixel((j,i)) for k in range(3): a.append(pixel[k])for i in a: if i%10==0: print(0,end=&#x27;&#x27;) elif i%10==5: print(1,end=&#x27;&#x27;) cyberchef转一下二进制： 得到脚本和一串密码 123456789101112131415161718import secret丁真 = np.float32(cv2.imread(r&quot;C:\\Users\\16334\\Desktop\\fadian.png&quot;, 1))for i in range(64): for j in range(64): 芝士 = randint(0,2) 小马珍珠 = 丁真[:, :, 芝士] 雪豹 = cv2.dct(小马珍珠[8*i:8*i+8, 8*j:8*j+8]) if(secret[i*64+j] == &#x27;1&#x27;): 雪豹[7,7] = 20 elif(secret[i*64+j] == &#x27;0&#x27;): 雪豹[7,7] = -20 小马珍珠[8*i:8*i+8, 8*j:8*j+8] = cv2.idct(雪豹) 丁真[:, :, 芝士] = 小马珍珠cv2.imwrite(r&quot;C:\\Users\\16334\\Desktop\\fd.png&quot;, 丁真)#a gift for you : %$#%$#jhgasdfg76342t........................ 这里给出的是一个加密脚本 把原图分成了许多8x8的块，然后在这个块上随机选择rgb通道中的一个进行dct变换（离散余弦变换），然后根据secret.txt里是1还是0来改变dct矩阵右下角的值，然后合并进原图，最后保存 解密脚本： 123456789101112import numpy as npimport cv2img = np.float32(cv2.imread(r&quot;C:\\Users\\19682\\Desktop\\fd.png&quot;, 1))for i in range(64): for j in range(64): for k in range(3): imgg=img[:, :, k] dctt = cv2.dct(imgg[8*i:8*i+8, 8*j:8*j+8]) if (dctt[7,7] &gt;= 10): print(&#x27;1&#x27;,end=&#x27;&#x27;) elif(dctt[7,7] &lt; -10): print(&#x27;0&#x27;,end=&#x27;&#x27;) 看了官解，dct会产生一些损失，因此与10进行比较 导入私钥结合之前的密码，得到flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"2022安洵杯","slug":"2022axbctf","date":"2022-11-26T16:00:00.000Z","updated":"2022-12-07T14:37:55.581Z","comments":true,"path":"2022/11/27/2022axbctf/","link":"","permalink":"http://example.com/2022/11/27/2022axbctf/","excerpt":"","text":"回家路上打的比赛，高铁站坐牢捏 CryptoCry1签到题，对四位数进行爆破即可 exp： 1234567891011from hashlib import *b=&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;a=&#x27;qD0FP6G2kS8QcpG7&#x27;for i in b: for j in b: for m in b: for n in b: c=str(i)+str(j)+str(m)+str(n)+a d=sha256(c.encode(&#x27;utf-8&#x27;)).hexdigest() if d==&#x27;86455b01fd7022f72ff93db1e9b2760cea520588db534cdeb3febb2d82a56e1e&#x27;: print(c) 不过拿flag还是比较看脸的qaq,试了无数次 MiscGumpKing 基于虚幻引擎的小游戏 给的文件没什么太大帮助，一开始还以为是修改配置文件去拿flag 这里使用作弊工具（cheat engine）去修改分数值 游戏全屏不太好使用ce进行扫描,alt+enter切换为窗口模式 思路： 游戏开始前即分数为零时对0进行扫描，分数发生变化时对当前分数进行再次扫描，直到确定记录分数的地址，另开一局对该地址的值进行更改即可 经过多次尝试终于确定了记录分数的地址： 修改其初始值 得到答案 little_thief流量包分析 常规操作，导出http流查看是否存在有用信息： 好，导出 有密码，找 追踪tcp流逐个分析 拉到最上面可以发现是登录信息 以游客身份登陆的信息，没啥用，再找 一眼jwt 好，解一下 找到压缩包密码了 打开flag.html，爆搜没有搜到flag,应该是隐写 使用wbStego4.3open进行解密，没有密钥 得 Redcoast一堆二进制，转为16进制保存，得到压缩包 将压缩包里的图片按25x25的大小进行排列，得到一个二维码 exp1: 123456789101112from PIL import Imageimport binasciiimport base64a=Image.new(&#x27;RGB&#x27;,(2500,2500),&#x27;white&#x27;)n=0for i in range(25): for j in range(25): b=Image.open(f&#x27;./pic/&#123;n&#125;.png&#x27;) a.paste(b,(100*j,100*i)) n+=1a.save(&#x27;6.png&#x27;) 扫描，得到压缩包密码： 打开里面还是一堆数字+字母 cyberchef: 是一张图片，但是存在许多混乱的像素带： 用stegsolve或者写脚本将每一个像素点的rgb提取并转为ascii exp2: 123456789101112131415from PIL import Imageimg = Image.open(r&#x27;C:\\Users\\19682\\Desktop\\3.png&#x27;)pixel =[]imgSize = img.sizex, y = imgSize[0], imgSize[1] # (x1200, y750)for i in range(y): for j in range(x): pixel.append(img.getpixel((j, i)))message = &#x27;&#x27;for i in pixel: for j in i: message += chr(j)with open(&#x27;flag.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(message) f.close()","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"DASCTF-month11","slug":"DAS11","date":"2022-11-26T16:00:00.000Z","updated":"2022-12-07T12:48:52.002Z","comments":true,"path":"2022/11/27/DAS11/","link":"","permalink":"http://example.com/2022/11/27/DAS11/","excerpt":"","text":"七仙女下凡附件给了6张包含内容相同的图片 对比观察可发现几张图片宽高之间存在一定的比例关系 尝试使用stegsovle中的image combiner模块进行组合 image combiner中存在多种组合方式（包括异或、或、与等），鉴于本题宽高的特殊比例，选择其中的水平交错（Vertical interlace）与垂直交错（Horizontal interlace） 交错存在以下顺序： 先1和2拼，垂直交错增加宽度，拼出来图片的再和3拼进行水平交错加高，再和4拼，加宽，再和5，加高，和6，加宽，最后和7，加高 导出7张图片合并完的最终结果，打开，观察颜色通道： red 0处存在明显异常，使用数据提取，rgb均选择最低位 根据16进制，存在jpg文件，导出改后缀 EzUSB这道题，根据后面的flag应该考查的是对于ntfs格式的usb硬盘的dbr分区恢复（事实上也确实是，因为观察dbr扇区可发现是全空的 但选择取证大师直接嗦 拉到取证大师直接深度恢复可发现题目中说的机密文件的压缩包 导出，打开提示文件格式错误 使用winhex查看 说实话，第一直觉，缺文件头，但观察主体也不像个zip文件的16进制格式 后来发现，是将zip文件的16进制进行了倒序 逆过来，单独保存，打开 这里放上皓文学长手修usb的dbr扇区的链接 Orz Dink Kirby PC（复现）与内存取证有关 vol分析一下内存镜像 导出notepad.exe的进程 命令： 1volatility_2.6_win64_standalone -f 66.raw --profile=Win7SP1x64 memdump -p 3860 -D ./ 发现一个带锁的压缩包，结合passkit提取的电脑开机密码可以解开 这里的perl命令不是太会，但是大体上的意思应该是对$_PASSWORD进行了加密，我们可以尝试手撸爆破出来，当然也可以写脚本 TeamGipsy的exp: 12345678910111213import stringx=&#x27;878189096364096066836664&#x27;string1=&#x27;0123456789&#x27;string2=&#x27;8195376024&#x27;string3=string.digits+string.ascii_lowercasestring4=string.ascii_lowercase+string.digitsx=x.translate(str.maketrans(string2,string1))flag=&#x27;&#x27;for i in range(0,len(x),2): flag+=chr(int(x[i:i+2])^0x31)flag=flag.translate(str.maketrans(string3,string4))print(flag)#ead803812f23 得到了aes的密钥，那么aes呢？ 应该还在内存里，找吧 经过aes加密的字符串都以U2Fsd开头，我们可以直接搜关键字 理论上取证大师的原始数据应该也可以搜索到 现在我们解密 拿这个密码去解密附件给的encrypt.crypto文件 ok了","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"迁移通知","slug":"test","date":"2022-11-24T16:00:00.000Z","updated":"2022-11-30T05:06:55.101Z","comments":true,"path":"2022/11/25/test/","link":"","permalink":"http://example.com/2022/11/25/test/","excerpt":"","text":"从最开始接触网安时使用的csdn,到后来利用腾讯云服务器和wordpress一步一步搭建的博客，再到最后的博客园 。最终还是选择了hexo+github搭建的静态博客网站。 csdn作为国内体量最大的IT学习平台，其资源量是巨大的，加上其较为完善的移动端app,有着不言而喻的便利性，无奈被其纷杂的广告劝退，但是用来搜集和学习知识还是不错的。 自己通过租用服务器并利用wordpress搭建的静态服务器，让自己对网站的结构有了更深刻的认识，然而不是每个大学牲都支付得起服务器的租金，加之服务器性能的原因，网站渲染起来很慢，最终没有再维护下去。 博客园相较于前两者，没有广告，加载起来也很快，还支持自定义js，可以满足博客的大部分需求，但是对我个人而言，还是更加青睐于一个没有后台的静态博客网站，因此最终选择了部署在github上的hexo。 目前还没有完全把hexo玩懂，愿我和我的小网站可以一起进步，一次成长吧！","categories":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}],"tags":[]}],"categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"},{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}],"tags":[{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]}