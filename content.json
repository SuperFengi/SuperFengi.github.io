{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"留言板","date":"2022-12-08T14:52:06.667Z","updated":"2022-12-08T14:52:06.667Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"这都被你发现了？ 留个言吧👇👇👇"},{"title":"分类","date":"2022-11-25T09:21:06.352Z","updated":"2022-11-25T08:04:09.721Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-11-25T08:04:09.722Z","updated":"2022-11-25T08:04:09.722Z","comments":false,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-11-25T09:21:18.139Z","updated":"2022-11-25T08:04:09.722Z","comments":true,"path":"links/index.html","permalink":"http://example.com/links/index.html","excerpt":"","text":""}],"posts":[{"title":"Docker学习","slug":"docker","date":"2022-12-29T16:00:00.000Z","updated":"2022-12-30T15:24:23.876Z","comments":true,"path":"2022/12/30/docker/","link":"","permalink":"http://example.com/2022/12/30/docker/","excerpt":"","text":"跟着狂神哥学docker 概述docker的由来Docker的思想来自于集装箱，集装箱解决了什么问题？在一艘大船上，可以把货物规整的摆放起来。并且各种各样的货物被集装箱标准化了，集装箱和集装箱之间不会互相影响。那么我就不需要专门运送水果的船和专门运送化学品的船了。只要这些货物在集装箱里封装的好好的，那我就可以用一艘大船把他们都运走。 docker与传统虚拟机的区别传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程； 而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。 每个容器之间互相隔离，每个容器有自己的文件系统 ，容器之间进程不会相互影响，能区分计算资源。 相关网站Docker官网：http://www.docker.com Docker中文网站：https://www.docker-cn.com Docker Hub官网：https://hub.docker.com docker的基本组成构架图 镜像Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 就好似 Java 中的 类和对象，类就是镜像，容器就是对象。 容器Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。 它可以被启动、开始、停止、删除。每个容器都是相互隔离的，保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 仓库仓库（Repository）是集中存放镜像文件的场所。 仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。 底层原理Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。 docker更快的原因1、docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 2、docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。 docker命令镜像命令docker images12345678910111213141516171819# 列出本地主机上的镜像[root@d3f4u1t ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEhello-world latest bf756fb1ae65 4 months ago 23.3kB# 解释REPOSITORY 镜像的仓库源TAG 镜像的标签IMAGE ID 镜像的IDCREATED 镜像创建时间SIZE 镜像大小# 同一个仓库源可以有多个 TAG，代表这个仓库源的不同版本，我们使用REPOSITORY：TAG 定义不同的镜像，如果你不定义镜像的标签版本，docker将默认使用 lastest 镜像！# 可选项-a： 列出本地所有镜像-q： 只显示镜像id--digests： 显示镜像的摘要信息 docker search1234567891011# 搜索镜像[root@d3f4u1t ~]# docker search mysqlNAME DESCRIPTION STARSOFFICIALmysql MySQL is a widely used, open-source relation… 9484[OK]# docker search 某个镜像的名称 对应DockerHub仓库中的镜像# 可选项--filter=stars=50 ： 列出收藏数不小于指定值的镜像。 docker pull123456789101112131415161718192021# 下载镜像[root@d3f4u1t ~]# docker pull mysqlUsing default tag: latest # 不写tag，默认是latest最新版本latest: Pulling from library/mysql54fec2fa59d0: Already exists # 分层下载bcc6c6145912: Already exists951c3d959c9d: Already exists05de4d0e206e: Already exists319f0394ef42: Already existsd9185034607b: Already exists013a9c64dadc: Already exists42f3f7d10903: Pull completec4a3851d9207: Pull completeDigest:sha256:61a2a33f4b8b4bc93b7b6b9e65e64044aaec594809f818aeffbff69a893d1944 #签名Status: Downloaded newer image for mysql:latestdocker.io/library/mysql:latest # 真实位置# 指定版本下载[root@d3f4u1t ~]# docker pull mysql:5.7.... docker rmi1234# 删除镜像docker rmi -f 镜像id # 删除单个docker rmi -f 镜像名:tag 镜像名:tag # 删除多个docker rmi -f $(docker images -qa) # 删除全部 容器命令有镜像才能创建容器，这里使用 centos 的镜像来测试，就是虚拟一个 centos 新建容器并启动12345678910111213141516171819202122232425# 命令docker run [OPTIONS] IMAGE [COMMAND][ARG...]# 常用参数说明--name=&quot;Name&quot; # 给容器指定一个名字-d # 后台方式运行容器，并返回容器的id！-i # 以交互模式运行容器，通过和 -t 一起使用-t # 给容器重新分配一个终端，通常和 -i 一起使用-P # 随机端口映射（大写）-p # 指定端口映射（小结），一般可以有四种写法ip:hostPort:containerPortip::containerPorthostPort:containerPort (常用)containerPort# 测试[root@d3f4u1t ~]# docker imagesREPOSITORY TAG IMAGE ID CREATED SIZEcentos latest 470671670cac 3 months ago 237MB# 使用centos进行用交互模式启动容器，在容器内执行/bin/bash命令！[root@d3f4u1t ~]# docker run -it centos /bin/bash[root@dc8f24dd06d0 /]# ls # 注意地址，已经切换到容器内部了！bin etc lib lost+found mnt proc run srv tmp vardev home lib64 media opt root sbin sys usr 列出所有运行的容器12345678# 命令docker ps [OPTIONS]# 常用参数说明-a # 列出当前所有正在运行的容器 + 历史运行过的容器-l # 显示最近创建的容器-n=? # 显示最近n个创建的容器-q # 静默模式，只显示容器编号。 退出容器12exit # 容器停止退出ctrl+P+Q # 容器不停止退出 启动时停止容器1234docker start (容器id or 容器名) # 启动容器docker restart (容器id or 容器名) # 重启容器docker stop (容器id or 容器名) # 停止容器docker kill (容器id or 容器名) # 强制停止容器 删除容器123docker rm 容器id # 删除指定容器docker rm -f $(docker ps -a -q) # 删除所有容器docker ps -a -q|xargs docker rm # 删除所有容器 其他命令后台启动容器1234567891011# 命令docker run -d 容器名# 例子docker run -d centos # 启动centos，使用后台方式启动# 问题： 使用docker ps 查看，发现容器已经退出了！# 解释：Docker容器后台运行，就必须有一个前台进程，容器运行的命令如果不是那些一直挂起的命令，就会自动退出。# 比如，你运行了nginx服务，但是docker前台没有运行应用，这种情况下，容器启动后，会立即自杀，因为他觉得没有程序了，所以最好的情况是，将你的应用使用前台进程的方式运行启动。 查看日志123456789101112131415161718192021222324# 命令docker logs -f -t --tail 容器id# eg:[root@d3f4u1t ~]# docker run -d centos /bin/sh -c &quot;while true;do echo kuangshen;sleep 1;done&quot;[root@d3f4u1t ~]# docker psCONTAINER ID IMAGEc8530dbbe3b4 centos# -t 显示时间戳# -f 打印最新的日志# --tail 数字 显示多少条！[root@d3f4u1t ~]# docker logs -tf --tail 10 c8530dbbe3b42020-05-11T08:46:40.656901941Z kuangshen2020-05-11T08:46:41.658765018Z kuangshen2020-05-11T08:46:42.661015375Z kuangshen2020-05-11T08:46:43.662865628Z kuangshen2020-05-11T08:46:44.664571547Z kuangshen2020-05-11T08:46:45.666718583Z kuangshen2020-05-11T08:46:46.668556725Z kuangshen2020-05-11T08:46:47.670424699Z kuangshen2020-05-11T08:46:48.672324512Z kuangshen2020-05-11T08:46:49.674092766Z kuangshen 查看容器中运行的进程信息，支持ps命令参数。1234567# 命令docker top 容器id# 测试[root@kuangshen ~]# docker top c8530dbbe3b4UID PID PPID C STIME TTY TIME CMDroot 27437 27421 0 16:43 ? 00:00:00 /bin/sh -c .... 查看容器镜像的元数据1234567891011121314151617181920212223242526272829303132# 命令docker inspect 容器id# 测试[root@d3f4u1t ~]# docker inspect c8530dbbe3b4[&#123;# 完整的id，这里上面的容器id，就是截取的这个id前几位&quot;Id&quot;:&quot;c8530dbbe3b44a0c873f2566442df6543ed653c1319753e34b400efa05f77cf8&quot;,&quot;Created&quot;: &quot;2020-05-11T08:43:45.096892382Z&quot;,&quot;Path&quot;: &quot;/bin/sh&quot;,&quot;Args&quot;: [&quot;-c&quot;,&quot;while true;do echo kuangshen;sleep 1;done&quot;],# 状态&quot;State&quot;: &#123;&quot;Status&quot;: &quot;running&quot;,&quot;Running&quot;: true,&quot;Paused&quot;: false,&quot;Restarting&quot;: false,&quot;OOMKilled&quot;: false,&quot;Dead&quot;: false,&quot;Pid&quot;: 27437,&quot;ExitCode&quot;: 0,&quot;Error&quot;: &quot;&quot;,&quot;StartedAt&quot;: &quot;2020-05-11T08:43:45.324474622Z&quot;,&quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;&#125;,// ...........] 进入正在运行的容器123456789101112131415161718192021222324252627282930313233343536# 命令1docker exec -it 容器id bashShell# 测试1[root@d3f4u1t ~]# docker psCONTAINER ID IMAGE COMMAND CREATEDSTATUS PORTS NAMESc8530dbbe3b4 centos &quot;/bin/sh -c &#x27;while t…&quot; 12 minutesago Up 12 minutes happy_chaum[root@d3f4u1t ~]# docker exec -it c8530dbbe3b4 /bin/bash[root@c8530dbbe3b4 /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 08:43 ? 00:00:00 /bin/sh -c while true;doecho kuangshen;sleeproot 751 0 0 08:56 pts/0 00:00:00 /bin/bashroot 769 1 0 08:56 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sroot 770 751 0 08:56 pts/0 00:00:00 ps -ef# 命令2docker attach 容器id# 测试2[root@d3f4u1t ~]# docker exec -it c8530dbbe3b4 /bin/bash[root@c8530dbbe3b4 /]# ps -efUID PID PPID C STIME TTY TIME CMDroot 1 0 0 08:43 ? 00:00:00 /bin/sh -c while true;doecho kuangshen;sleeproot 856 0 0 08:57 pts/0 00:00:00 /bin/bashroot 874 1 0 08:57 ? 00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sroot 875 856 0 08:57 pts/0 00:00:00 ps -ef# 区别# exec 是在容器中打开新的终端，并且可以启动新的进程# attach 直接进入容器启动命令的终端，不会启动新的进程 从容器中拷贝内容到主机上1234567891011121314151617# 命令docker cp 容器id:容器内路径 目的主机路径# 测试# 容器内执行，创建一个文件测试[root@c8530dbbe3b4 /]# cd /home[root@c8530dbbe3b4 home]# touch f1[root@c8530dbbe3b4 home]# lsf1[root@c8530dbbe3b4 home]# exitexit# linux复制查看，是否复制成功[root@d3f4u1t ~]# docker cp c8530dbbe3b4:/home/f1 /home[root@d3f4u1t ~]# cd /home[root@d3f4u1t home]# lsf1 总结 常用命令： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374attach: Attach to a running container # 当前 shell 下attach 连接指定运行镜像build: Build an image from a Dockerfile # 通过 Dockerfile 定制镜像commit: Create a new image from a container changes # 提交当前容器为新的镜像cp: Copy files/folders from the containers filesystem to the host path#从容器中拷贝指定文件或者目录到宿主机中create: Create a new container # 创建一个新的容器，同run，但不启动容器diff: Inspect changes on a container&#x27;s filesystem # 查看 docker 容器变化events: Get real time events from the server # 从 docker 服务获取容器实时事件exec: Run a command in an existing container # 在已存在的容器上运行命令export: Stream the contents of a container as a tar archive # 导出容器的内容流作为一个 tar 归档文件[对应 import ]history: Show the history of an image # 展示一个镜像形成历史images: List images # 列出系统当前镜像import: Create a new filesystem image from the contents of a tarball # 从tar包中的内容创建一个新的文件系统映像[对应export]info: Display system-wide information # 显示系统相关信息inspect: Return low-level information on a container # 查看容器详细信息kill: Kill a running container # kill 指定 docker 容器load: Load an image from a tar archive # 从一个 tar 包中加载一个镜像[对应 save]login: Register or Login to the docker registry server # 注册或者登陆一个docker 源服务器logout: Log out from a Docker registry server # 从当前 Dockerregistry 退出logs: Fetch the logs of a container # 输出当前容器日志信息port: Lookup the public-facing port which is NAT-ed to PRIVATE_PORT #查看映射端口对应的容器内部源端口pause: Pause all processes within a container # 暂停容器ps: List containers # 列出容器列表pull: Pull an image or a repository from the docker registry server #从docker镜像源服务器拉取指定镜像或者库镜像push: Push an image or a repository to the docker registry server #推送指定镜像或者库镜像至docker源服务器restart: Restart a running container # 重启运行的容器rm: Remove one or more containers # 移除一个或者多个容器rmi: Remove one or more images # 移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或 -f 强制删除]run: Run a command in a new container # 创建一个新的容器并运行一个命令save: Save an image to a tar archive # 保存一个镜像为一个tar 包[对应 load]search: Search for an image on the Docker Hub # 在 docker hub 中搜索镜像start: Start a stopped containers # 启动容器stop: Stop a running containers # 停止容器tag: Tag an image into a repository # 给源中镜像打标签top: Lookup the running processes of a container # 查看容器中运行的进程信息unpause: Unpause a paused container # 取消暂停容器version: Show the docker version information # 查看 docker 版本号wait: Block until a container stops, then print its exit code # 截取容器停止时的退出状态值 docker镜像详解何为镜像镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。 加载原理docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。 bootfs(boot fifile system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。 rootfs (root fifile system) ，在bootfs之上。包含的就是典型 Linux 系统中的 &#x2F;dev, &#x2F;proc, &#x2F;bin, &#x2F;etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 分层结构docker镜像采用分层结构，最大的好处莫过于资源共享。比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。 理解： 所有的 Docker 镜像都起始于一个基础镜像层，当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。 举一个简单的例子，假如基于 Ubuntu Linux 16.04 创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创建第三个镜像层。 特点Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部 这一层就是我们通常说的容器层，容器之下的都叫镜像层 容器数据卷何为容器数据卷卷就是目录或者文件，存在一个或者多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过 Union File System ， 提供一些用于持续存储或共享数据的特性： 卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷。 特点： 1、数据卷可在容器之间共享或重用数据 2、卷中的更改可以直接生效 3、数据卷中的更改不会包含在镜像的更新中 4、数据卷的生命周期一直持续到没有容器使用它为止 使用数据卷方式一：命令行12345# 命令docker run -it -v 宿主机绝对路径目录:容器内目录 镜像名# 测试[root@d3f4u1t ~]# docker run -it -v /home/ceshi:/home centos /bin/bash 挂载分为匿名挂载和具名挂载 123456789101112131415161718192021222324252627282930313233# 匿名挂载-v 容器内路径docker run -d -P --name nginx01 -v /etc/nginx nginx# 匿名挂载的缺点，就是不好维护，通常使用命令 docker volume维护docker volume ls# 具名挂载-v 卷名:/容器内路径docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx nginx# 查看挂载的路径[root@d3f4u1t ~]# docker volume inspect nginxconfig[&#123;&quot;CreatedAt&quot;: &quot;2020-05-13T17:23:00+08:00&quot;,&quot;Driver&quot;: &quot;local&quot;,&quot;Labels&quot;: null,&quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/nginxconfig/_data&quot;,&quot;Name&quot;: &quot;nginxconfig&quot;,&quot;Options&quot;: null,&quot;Scope&quot;: &quot;local&quot;&#125;]# 怎么判断挂载的是卷名而不是本机目录名？不是/开始就是卷名，是/开始就是目录名# 改变文件的读写权限# ro: readonly# rw: readwrite# 指定容器对我们挂载出来的内容的读写权限docker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:ro nginxdocker run -d -P --name nginx02 -v nginxconfig:/etc/nginx:rw nginx 方式二：dockerfile123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657# 1、我们在宿主机 /home 目录下新建一个 docker-test-volume文件夹[root@d3f4u1t home]# mkdir docker-test-volume# 说明：在编写DockerFile文件中使用 VOLUME 指令来给镜像添加一个或多个数据卷VOLUME[&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]# 出于可移植和分享的考虑，我们之前使用的 -v 主机目录:容器目录 这种方式不能够直接在DockerFile中实现。# 由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有宿主机上都存在这样的特定目录.# 2、编写DockerFile文件[root@d3f4u1t docker-test-volume]# pwd/home/docker-test-volume[root@d3f4u1t docker-test-volume]# vim dockerfile1[root@d3f4u1t docker-test-volume]# cat dockerfile1# volume testFROM centosVOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;]CMD echo &quot;-------end------&quot;CMD /bin/bash# 3、build后生成镜像，获得一个新镜像 d3f4u1t/centosdocker build -f /home/docker-test-volume/dockerfile1 -t kuangshen/centos . #注意最后有个.# 4、启动容器[root@d3f4u1tn docker-test-volume]# docker run -it 0e97e1891a3d /bin/bash #启动容器[root@f5824970eefc /]# ls -ltotal 56lrwxrwxrwx 1 root root 7 May 11 2019 bin -&gt; usr/bindrwxr-xr-x 2 root root 4096 May 11 11:55 dataVolumeContainer1 # 数据卷目录drwxr-xr-x 2 root root 4096 May 11 11:55 dataVolumeContainer2 # 数据卷目录drwxr-xr-x 5 root root 360 May 11 11:55 devdrwxr-xr-x 1 root root 4096 May 11 11:55 etcdrwxr-xr-x 2 root root 4096 May 11 2019 home.....# 问题:通过上述步骤，容器内的卷目录地址就已经知道了，但是对应的主机目录地址在哪里呢？# 5、我们在数据卷中新建一个文件[root@f5824970eefc dataVolumeContainer1]# pwd/dataVolumeContainer1[root@f5824970eefc dataVolumeContainer1]# touch container.txt[root@f5824970eefc dataVolumeContainer1]# ls -ltotal 0-rw-r--r-- 1 root root 0 May 11 11:58 container.txt# 6、查看下这个容器的信息[root@d3f4u1t ~]# docker inspect 0e97e1891a3d# 查看输出的Volumes&quot;Volumes&quot;: &#123;&quot;/dataVolumeContainer1&quot;: &#123;&#125;,&quot;/dataVolumeContainer2&quot;: &#123;&#125;&#125;,# 7、这个卷在主机对应的默认位置 数据卷容器命名的容器挂载数据卷，其他容器通过挂载这个（父容器）实现数据共享，挂载数据卷的容器，称之为数据卷容器。 容器之间配置信息的传递，数据卷的生命周期一直持续到没有容器使用它为止。 存储在本机的文件则会一直保留 dockerfile何为dockerfiledockerfifile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 构建步骤： 1、编写DockerFile文件 2、docker build 构建镜像 3、docker run 构建dockerfile基础知识： 1、每条保留字指令(命令)都必须为大写字母且后面要跟随至少一个参数 2、指令按照从上到下，顺序执行 3、# 表示注释 4、每条指令都会创建一个新的镜像层，并对镜像进行提交 流程： 1、docker从基础镜像运行一个容器 2、执行一条指令并对容器做出修改 3、执行类似 docker commit 的操作提交一个新的镜像层 4、Docker再基于刚提交的镜像运行一个新容器 5、执行dockerfifile中的下一条指令直到所有指令都执行完成！ dockerfile指令关键字12345678910111213FROM # 基础镜像，当前新镜像是基于哪个镜像的MAINTAINER # 镜像维护者的姓名混合邮箱地址RUN # 容器构建时需要运行的命令EXPOSE # 当前容器对外保留出的端口WORKDIR # 指定在创建容器后，终端默认登录的进来工作目录，一个落脚点ENV # 用来在构建镜像过程中设置环境变量ADD # 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包COPY # 类似ADD，拷贝文件和目录到镜像中！VOLUME # 容器数据卷，用于数据保存和持久化工作CMD # 指定一个容器启动时要运行的命令，dockerFile中可以有多个CMD指令，但只有最后一个生效！ENTRYPOINT # 指定一个容器启动时要运行的命令！和CMD一样ONBUILD # 当构建一个被继承的DockerFile时运行命令，父镜像在被子镜像继承后，父镜像的ONBUILD被触发 CMD 和 ENTRYPOINT 的区别我们之前说过，两个命令都是指定一个容器启动时要运行的命令 CMD：Dockerfile 中可以有多个CMD 指令，但只有最后一个生效，CMD 会被 docker run 之后的参数替换 ENTRYPOINT： docker run 之后的参数会被当做参数传递给 ENTRYPOINT，之后形成新的命令组合","categories":[{"name":"wiki","slug":"wiki","permalink":"http://example.com/categories/wiki/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"}]},{"title":"2022RCTF","slug":"2022rctf","date":"2022-12-13T16:00:00.000Z","updated":"2022-12-28T09:11:14.310Z","comments":true,"path":"2022/12/14/2022rctf/","link":"","permalink":"http://example.com/2022/12/14/2022rctf/","excerpt":"","text":"坐牢坐牢坐牢orz ez_alientalien.bmp文件尾部存在压缩包解压密码 解压后文件查看文件头发现为可执行文件，运行后发现为pygame即pyexe 使用pyinstxtractor.py解包可得pyc文件 1python pyinstxtractor.py alien_invasion.exe 同路径下会出现的[xxx.exe]_extracted的文件夹里面就包含了主程序main，但不带任何后缀，我们要反编译的就是这个文件，其他的都是依赖库，如PYZ-extracted文件夹里的都是库文件（用于import）。 至于为什么该文件不是.pyc文件，应该是pyinstxtractor的一点不足，转换出来的主程序格式不对，因此还需要对其进行手动修复。这里了解下不同版本python下pyc文件头的结构（链接）： Python3.3以下的版本中，只有Magic Number和四位时间戳（共8字节）Python3.3到Python3.7（不包含3.7）版本中，只有Magic Number和八位时间戳 + 大小信息（共12字节）Python3.7及以上版本的编译后二进制文件中，头部除了四字节Magic Number，还有四个字节的空位和八个字节的时间戳 + 大小信息（共16字节），后者（指后12字节）对文件反编译没有影响，全部填充0即可 python Magic Number对照表 1234567891011121314151617181920212223242526enum PycMagic &#123; MAGIC_1_0 = 0x00999902, MAGIC_1_1 = 0x00999903, /* Also covers 1.2 */ MAGIC_1_3 = 0x0A0D2E89, MAGIC_1_4 = 0x0A0D1704, MAGIC_1_5 = 0x0A0D4E99, MAGIC_1_6 = 0x0A0DC4FC, MAGIC_2_0 = 0x0A0DC687, MAGIC_2_1 = 0x0A0DEB2A, MAGIC_2_2 = 0x0A0DED2D, MAGIC_2_3 = 0x0A0DF23B, MAGIC_2_4 = 0x0A0DF26D, MAGIC_2_5 = 0x0A0DF2B3, MAGIC_2_6 = 0x0A0DF2D1, MAGIC_2_7 = 0x0A0DF303, MAGIC_3_0 = 0x0A0D0C3A, MAGIC_3_1 = 0x0A0D0C4E, MAGIC_3_2 = 0x0A0D0C6C, MAGIC_3_3 = 0x0A0D0C9E, MAGIC_3_4 = 0x0A0D0CEE, MAGIC_3_5 = 0x0A0D0D16, MAGIC_3_5_3 = 0x0A0D0D17, MAGIC_3_6 = 0x0A0D0D33, MAGIC_3_7 = 0x0A0D0D42, MAGIC_3_8 = 0x0A0D0D55, MAGIC_3_9 = 0x0A0D0D61, &#125;; 根据其他解包好的pyc文件头且这里是py38，第一行添加16个字节去修主函数即可成功逆向 这里发现其他pyc即使解包出来也没办法直接逆（？，和上面主函数第一行修改一致即可成功逆向 以上内容大致意思就是文件头格式不对（链接） 依照主函数的第一行修改如下： 逆完后面的步骤就比较简单了，主文件及其中引用到的库函数中均存在一个base64后的片段，解码后拼接即可。 ez_pvz逆向大佬都是ida梭的orz 我当时只用ce通了一关，一直想锁定阳光的基址（奈何失败qaq 做法： 第一关：搜100，种豌豆，搜0，确定阳光临时地址 第二关：开局搜150，几十个数，挨个改为0，前几个改完查看游戏就发现找到了双豌豆和樱桃炸弹的费用地址，修改为零即可 第三关：做法同第二关，找到费用地址后查看内存，可以发现动态变化的内存地址即cd的变化地址，其后面的一个字节也会随着前面的变化规律变化，观察一会发现会从01（满cd）递增到10（无cd），一直修改为10即可实现无cd","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"⎛⎝龙猫⎠⎞","slug":"Totoro","date":"2022-12-11T16:00:00.000Z","updated":"2022-12-12T15:17:43.541Z","comments":true,"path":"2022/12/12/Totoro/","link":"","permalink":"http://example.com/2022/12/12/Totoro/","excerpt":"","text":"lazzzaro师傅出的一道题 下载附件改后缀为.zip 解压出一张打不开的图片和带密码的压缩包 打不开的图片的16进制头与正常jpg比较后发现规律 0101修改为正常图片得到： 发现图片16进制尾部隐藏的信息，转两次hex得到： 得到压缩包密码并提示进行异或 起初以为是对key文件进行异或，并且key文件与2B异或完确实还能得到一张图片 后来发现相偏了，这里考查的并不是双图隐写 因为key文件导入到010保存后的大小是和totoro.jpg一样的，所以是用key直接和totoro.jpg逐字节异或 exp： 1234567891011121314f1=open(r&#x27;C:\\Users\\19682\\Desktop\\Totoro.jpg&#x27;,&#x27;rb&#x27;)f11=f1.read()f2=open(r&#x27;C:\\Users\\19682\\Desktop\\key&#x27;,&#x27;rb&#x27;)f22=f2.read()print(len(f11))print(len(f22))res=&#x27;&#x27;for i in range(len(f11)): res+=chr(f11[i]^f22[i])b=open(&#x27;1234&#x27;,&#x27;w&#x27;)b.write(res)f1.close()f2.close() 得到的文件导入010得： 在众多+号中存在一段特殊序列，包含+[&gt;&lt;-.]，即两个问号中间得部分 复制到brainfuck解密得到flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"ShowTime","slug":"ShowTime","date":"2022-12-11T16:00:00.000Z","updated":"2022-12-12T15:17:40.202Z","comments":true,"path":"2022/12/12/ShowTime/","link":"","permalink":"http://example.com/2022/12/12/ShowTime/","excerpt":"","text":"Tokeii师傅在i春秋上出的一道题，挺新奇的，记录一下 思路源于他的这篇博客 下载后的附件，名字都是base64编码的，写脚本改名 123456p=r&#x27;C:\\Users\\19682\\Desktop\\stego&#123;&#125;&#x27;.format(&#x27;\\\\&#x27;)for i in filelist: b=i[:-4] a=base64.b64decode(b) c=a.decode(&#x27;UTF-8&#x27;) d=os.rename(p+i,p+c+&#x27;.txt&#x27;) 提取每个文件修改时间戳的最后一位 1234567import osfor i in range(925): filename = r&quot;C:\\Users\\19682\\Desktop\\stego\\&#123;&#125;.txt&quot;.format(i) file_attr = os.stat(filename)#读取文件属性 create_time = str(file_attr.st_mtime)#获取修改时间 # print(create_time) print(int(create_time[9:10]),end=&#x27;&#x27;) 将数字转字符串 123from numlib import *a=1774674557824868457499061032120895601890679002715594296727500711025736399907449201395656994728720806964341210442762667972497818255944821704615312664370539310702290900650405564784263444957700019095984690444788205828883771674746086773438649406269794894162345496646835920006634655790770023591140601368298957582899939643842210521270729599027362038934484123582308984705653794101554567102555263227506545092094002357706759680210528515040207139078660910227189154726011658251525180920105580373673544062554076786313766549322038531510544996944293029774158028502472577209425526755227464619459049995527828690565067923263594211663575768777749797684020900044480050567580861721772084896501068329188549341576999149193729307442677823665245077311594986800407693715823937313065541334395357854650051549808442561638033762084503042808464197473992558178954715114984494063565778497512453063854507422273051449037068016131470694073345956605305655737661print (n2s(a)) 得到一串base64 拿到cyberchef解码保存为7z文件解压后打开即得flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]},{"title":"首届“天权信安&catf1ag”网络安全联合公开赛","slug":"catflag","date":"2022-12-08T16:00:00.000Z","updated":"2022-12-11T15:51:45.928Z","comments":true,"path":"2022/12/09/catflag/","link":"","permalink":"http://example.com/2022/12/09/catflag/","excerpt":"","text":"比赛介绍：本次竞赛旨在通过以赛促学、以赛促进的竞赛提升方式，面向网络安全从业者、兴趣爱好者、在校学生，通过竞技比武，检验参赛人员的网络安全综合能力，培养和选拔一批高素质网络安全人才，进而营造良好的网络安全知识学习和技能提升氛围，吸引更多高校学生投身网络强国建设事业，推动网络安全人才的培养，以及加快高校网络安全人才的储备，为国家网络安全建设添砖加瓦，为行业技术提升创新贡献自己的力量。 比赛总结： 赛题难度适中，自身仍有很大提升空间orz Crypto疑惑exp: 1234567# 题目介绍：我好&quot;疑惑&quot;啊# keys1 = welcome_to_nine-ak_match_is_so_easy_!@!# keys2 = 20 4 24 5 94 12 2 36 26 6 49 11 68 15 14 114 12 10 43 14 9 43 10 27 31 31 22 45 10 48 58 4 18 10 38 31 14 97 92a=[20,4,24,5,94,12,2,36,26,6,49,11,68,15,14,114,12,10,43,14,9,43,10,27,31,31,22,45,10,48,58,4,18,10,38,31,14,97,92]b=&#x27;welcome_to_nine-ak_match_is_so_easy_!@!&#x27;for i in range(len(b)): print(chr(ord(b[i])^a[i]),end=&#x27;&#x27;) catf1ag{nine-ak_match_is@very_easy_@&#x2F;!} easyrsaexp： 1234567from Crypto.Util.number import *e = 0x10001d=12344766091434434733173074189627377553017680360356962089159282442350343171988536143126785315325155784049041041740294461592715296364871912847202681353107182427067350160760722505537695351060872358780516757652343767211907987297081728669843916949983336698385141593880433674937737932158161117039734886760063825649623992179585362400642056715249145349214196969590250787495038347519927017407204272334005860911299915001920451629055970214564924913446260348649062607855669069184216149660211811217616624622378241195643396616228441026080441013816066477785035557421235574948446455413760957154157952685181318232685147981777529010093c=11665709552346194520404644475693304343544277312139717618599619856028953672850971126750357095315011211770308088484683204061365343120233905810281045824420833988717463919084545209896116273241788366262798828075566212041893949256528106615605492953529332060374278942243879658004499423676775019309335825331748319484916607746676069594715000075912334306124627379144493327297854542488373589404460931325101587726363963663368593838684601095345900109519178235587636259017532403848656471367893974805399463278536349688131608183835495334912159111202418065161491440462011639125641718883550113983387585871212805400726591849356527011578n=13717871972706962868710917190864395318380380788726354755874864666298971471295805029284299459288616488109296891203921497014120460143184810218680538647923519587681857800257311678203773339140281665350877914208278709865995451845445601706352659259559793431372688075659019308448963678380545045143583181131530985665822655263963917413080872997526445384954610888776917323156325542921415838122754036103689148810677276471252057077595104724365967333418002158480223657363936976281758713027828747277980907153645847605403914070601944617432177385048803228970693240587900504431163155958465431312258451026447435473865563581029300541109m=pow(c,d,n)print(long_to_bytes(m)) flag{3895dfda-67b1-11ed-b784-b07b2568d266} passwdexp: 1234567891011from hashlib import *a=&#x27;&#x27;for i in range(1,13): for j in range(1,32): for m in range(1,25): for n in range(1,61): c=&#x27;2022&#x27;+str(&quot;%02d&quot; % i)+&#x27;&#x27;+str(&quot;%02d&quot; % j)+&#x27;&#x27;+str(&quot;%02d&quot; % m)+&#x27;&#x27;+str(&quot;%02d&quot; % n)+&#x27;&#x27; d=sha256(c.encode(&#x27;utf-8&#x27;)).hexdigest() if d==&#x27;69d00d9bc39e01687abf84e98e27c889cf1442b53edba27d3235acbeb7b0ae95&#x27;: print(c) catf1ag{202211121750} Misc十位马将文件里的16进制放到cyberchef转hex再倒序，以zip格式保存 打开发现一对正方形图片 根据具有顺序的名字，考虑进行拼图 脚本： 123456789101112from PIL import Imageimport binasciiimport base64a=Image.new(&#x27;RGB&#x27;,(300,300),&#x27;white&#x27;)n=0for i in range(10): for j in range(10): b=Image.open(f&#x27;./WHAT_1S_FLAG/WHAT_1S_FLAG_&#123;n&#125;.png&#x27;) a.paste(b,(30*j,30*i)) n+=1a.save(&#x27;7.png&#x27;) 拼好的图片： 手动ps上两个定位符，到在线网站进行识别 flag{cbef4c93-5e9c-11ed-8205-666c80085daf} 简单隐写（复现）图片尾部存在rar压缩包，kali里面dd命令分离 压缩包加密 由于没有见过这种隐写，一直也没有写出来 考查jphide隐写 使用jphs无密码解密 主要也不清楚该隐写有什么特征，问群友说一个一个试，还是见得太少了orz 使用密码解压 凯撒密码： 阿sir（复现）以为相对拿手的电子取证来了，结果到快结束才找到能解这个零宽的网站orz 零宽解密: 取证大师挂载 发现桌面上的一张图片16进制末尾有东西 将megrez前面的字母和数字以及最后的’&#x3D;‘提取出来 得到 解一下base 缓存记录里可以看到缓存了两个百度网盘的文件 上面的密码解不开 后来发现是最后一个是大写字母I而不是小写字母l 有点脑洞有点坑。。。 给了图片和一些名字不同的压缩包，压缩包名在传递信息，结合图片名中的stego应该是lsb隐写 人为创的压缩包肯定存在创建的时间顺序 写脚本解一下名字： 12345import osfilelist = os.listdir(r&#x27;C:\\Users\\19682\\Desktop\\123&#x27;)dir_list = sorted(filelist,key=lambda x: os.path.getmtime(os.path.join(r&#x27;C:\\Users\\19682\\Desktop\\123&#x27;, x)))for i in dir_list: print(chr(int(i.split(&#x27;.&#x27;)[0][1:])),end=&#x27;&#x27;) 继续凯撒爆破一下 解密得到flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"2022NCTF","slug":"2022nctf","date":"2022-12-04T16:00:00.000Z","updated":"2022-12-11T15:43:41.259Z","comments":true,"path":"2022/12/05/2022nctf/","link":"","permalink":"http://example.com/2022/12/05/2022nctf/","excerpt":"","text":"比赛介绍 本届NCTF是由X1cT34m战队组织，将采用在线网络安全夺旗挑战赛的形式，面向全球开放. 比赛总结 在比赛时间内没有做出几道来，几乎都是有思路可以做几步但又做不全得不到最后的flag，很难受，还是太菜 MISC只因因根据题目描述去该网站搜索即可，搜索结果的第一个md5值即为flag Signin一开始没理解秘籍的含义，bing上搜索并没有相关暗示，换百度可以发现是魂斗罗的秘籍 直接肉眼ocr qrssssssss（复现）二维码相关的题目，是得好好学习一下二维码有关知识了 附件给了一堆二维码,批量扫完再字频统计，应该是将flag打乱顺序乱序16次 这里的考点其实二维码的纠错码，算上nctf{}加上括号内的26位，正好照应LMQH的32个纠错等级 通过CQR再结合字频统计的字符其实是可以手撸出来的 这里先放上作者的官解,具体的学习放在其他博客了： 1234567891011121314151617181920212223242526272829from PIL import Imagefrom pyzbar.pyzbar import decodeimport os​def maskanalysis(img): sign=&#x27;&#x27; for ii in range(510,670,20): pi=img.getpixel((ii,170)) if(pi==0): sign+=&#x27;1&#x27; if(pi==255): sign+=&#x27;0&#x27; return sign​def scanqr(img): decocdeQR = decode(img) return decocdeQR[0].data.decode(&#x27;ascii&#x27;)​qrlist=os.listdir(r&quot;C:\\Users\\16334\\Desktop\\qrssssssss_revenge&quot;)flag=[0]*32masklist=[&#x27;11000100&#x27;,&#x27;11110011&#x27;,&#x27;10101010&#x27;,&#x27;10011101&#x27;,&#x27;00101111&#x27;,&#x27;00011000&#x27;,&#x27;01000001&#x27;,&#x27;01110110&#x27;,&#x27;00010010&#x27;,&#x27;00100101&#x27;,&#x27;01111100&#x27;,&#x27;01001011&#x27;,&#x27;11111001&#x27;,&#x27;11001110&#x27;,&#x27;10010111&#x27;,&#x27;10100000&#x27;,&#x27;01011111&#x27;,&#x27;01101000&#x27;,&#x27;00110001&#x27;,&#x27;00000110&#x27;,&#x27;10110100&#x27;,&#x27;10000011&#x27;,&#x27;11011010&#x27;,&#x27;11101101&#x27;,&#x27;10001001&#x27;,&#x27;10111110&#x27;,&#x27;11100111&#x27;,&#x27;11010000&#x27;,&#x27;01100010&#x27;,&#x27;01010101&#x27;,&#x27;00001100&#x27;,&#x27;00111011&#x27;]for i in qrlist: img=Image.open(r&quot;C:\\Users\\16334\\Desktop\\qrssssssss_revenge\\&#123;&#125;&quot;.format(i)) qrmask=maskanalysis(img) for j in range(32): if(masklist[j]==qrmask): flag[j]=scanqr(img)​print(&#x27;&#x27;.join(flag)) 炉边聚会（复现）不是炉石玩家，但好像网上是有不止一篇对炉石卡牌代码的描述的，只能说信息检索能力不足。。。 123456fflag=[&#x27;10001100&#x27;,&#x27;00000110&#x27;,&#x27;10011110&#x27;,&#x27;00000101&#x27;,&#x27;11001000&#x27;,&#x27;00000110&#x27;,&#x27;10111100&#x27;,&#x27;00000101&#x27;,&#x27;11001110&#x27;,&#x27;00001001&#x27;,&#x27;11010000&#x27;,&#x27;00000101&#x27;,&#x27;11110010&#x27;,&#x27;00000111&#x27;,&#x27;11001010&#x27;,&#x27;00000111&#x27;,&#x27;11110100&#x27;,&#x27;00001000&#x27;,&#x27;10001000&#x27;,&#x27;00001001&#x27;,&#x27;10010000&#x27;,&#x27;00001000&#x27;,&#x27;10111110&#x27;,&#x27;00000110&#x27;,&#x27;10001000&#x27;,&#x27;00001001&#x27;,&#x27;11010110&#x27;,&#x27;00001000&#x27;,&#x27;11001100&#x27;,&#x27;00001000&#x27;,&#x27;11110010&#x27;,&#x27;00000111&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;10011110&#x27;,&#x27;00000101&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;11101000&#x27;,&#x27;00000111&#x27;,&#x27;11110010&#x27;,&#x27;00000111&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;10111110&#x27;,&#x27;00000110&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;11100000&#x27;,&#x27;00000011&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;10111100&#x27;,&#x27;00000101&#x27;,&#x27;10010010&#x27;,&#x27;00001001&#x27;,&#x27;11001100&#x27;,&#x27;00001000&#x27;,&#x27;11001100&#x27;,&#x27;00001000&#x27;,&#x27;11111010&#x27;,&#x27;00000110&#x27;,&#x27;10110110&#x27;,&#x27;00000111&#x27;,&#x27;11110100&#x27;,&#x27;00001000&#x27;,&#x27;10011010&#x27;,&#x27;00001000&#x27;,&#x27;10111010&#x27;,&#x27;00000100&#x27;,&#x27;10010000&#x27;,&#x27;00001000&#x27;,&#x27;10001000&#x27;,&#x27;00001001&#x27;,&#x27;11110110&#x27;,&#x27;00000100&#x27;,&#x27;11100010&#x27;,&#x27;00001001&#x27;,&#x27;00000000&#x27;,&#x27;00000000&#x27;]for i in range(40): flag=fflag[2*i+1]+fflag[2*i][1:-1]+fflag[2*i][-1] fla=int(flag,2) fl=fla//10 print(chr(fl),end=&#x27;&#x27;) zystego（复现）图片末尾提取压缩包爆破 得到一个假flag和私钥文件 打开ps观察图片发现右侧通道异常 提取右三列像素点： 1234567891011from PIL import Imagew=515h=512img=Image.open(r&quot;C:\\Users\\19682\\Desktop\\fd.png&quot;)a=[]for i in range(h): for j in range(w-3,w): pixel=img.getpixel((j,i)) for k in range(3): a.append(pixel[k])print(a) 都是0或5结尾的，考虑二进制0和1，写脚本转一下 1234567891011121314151617from PIL import Imagew=515h=512img=Image.open(r&quot;C:\\Users\\19682\\Desktop\\fd.png&quot;)a=[]for i in range(h): for j in range(w-3,w): pixel=img.getpixel((j,i)) for k in range(3): a.append(pixel[k])for i in a: if i%10==0: print(0,end=&#x27;&#x27;) elif i%10==5: print(1,end=&#x27;&#x27;) cyberchef转一下二进制： 得到脚本和一串密码 123456789101112131415161718import secret丁真 = np.float32(cv2.imread(r&quot;C:\\Users\\16334\\Desktop\\fadian.png&quot;, 1))for i in range(64): for j in range(64): 芝士 = randint(0,2) 小马珍珠 = 丁真[:, :, 芝士] 雪豹 = cv2.dct(小马珍珠[8*i:8*i+8, 8*j:8*j+8]) if(secret[i*64+j] == &#x27;1&#x27;): 雪豹[7,7] = 20 elif(secret[i*64+j] == &#x27;0&#x27;): 雪豹[7,7] = -20 小马珍珠[8*i:8*i+8, 8*j:8*j+8] = cv2.idct(雪豹) 丁真[:, :, 芝士] = 小马珍珠cv2.imwrite(r&quot;C:\\Users\\16334\\Desktop\\fd.png&quot;, 丁真)#a gift for you : %$#%$#jhgasdfg76342t........................ 这里给出的是一个加密脚本 把原图分成了许多8x8的块，然后在这个块上随机选择rgb通道中的一个进行dct变换（离散余弦变换），然后根据secret.txt里是1还是0来改变dct矩阵右下角的值，然后合并进原图，最后保存 解密脚本： 123456789101112import numpy as npimport cv2img = np.float32(cv2.imread(r&quot;C:\\Users\\19682\\Desktop\\fd.png&quot;, 1))for i in range(64): for j in range(64): for k in range(3): imgg=img[:, :, k] dctt = cv2.dct(imgg[8*i:8*i+8, 8*j:8*j+8]) if (dctt[7,7] &gt;= 10): print(&#x27;1&#x27;,end=&#x27;&#x27;) elif(dctt[7,7] &lt; -10): print(&#x27;0&#x27;,end=&#x27;&#x27;) 看了官解，dct会产生一些损失，因此与10进行比较 导入私钥结合之前的密码，得到flag","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"2022安洵杯","slug":"2022axbctf","date":"2022-11-26T16:00:00.000Z","updated":"2022-12-07T14:37:55.581Z","comments":true,"path":"2022/11/27/2022axbctf/","link":"","permalink":"http://example.com/2022/11/27/2022axbctf/","excerpt":"","text":"回家路上打的比赛，高铁站坐牢捏 CryptoCry1签到题，对四位数进行爆破即可 exp： 1234567891011from hashlib import *b=&#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;a=&#x27;qD0FP6G2kS8QcpG7&#x27;for i in b: for j in b: for m in b: for n in b: c=str(i)+str(j)+str(m)+str(n)+a d=sha256(c.encode(&#x27;utf-8&#x27;)).hexdigest() if d==&#x27;86455b01fd7022f72ff93db1e9b2760cea520588db534cdeb3febb2d82a56e1e&#x27;: print(c) 不过拿flag还是比较看脸的qaq,试了无数次 MiscGumpKing 基于虚幻引擎的小游戏 给的文件没什么太大帮助，一开始还以为是修改配置文件去拿flag 这里使用作弊工具（cheat engine）去修改分数值 游戏全屏不太好使用ce进行扫描,alt+enter切换为窗口模式 思路： 游戏开始前即分数为零时对0进行扫描，分数发生变化时对当前分数进行再次扫描，直到确定记录分数的地址，另开一局对该地址的值进行更改即可 经过多次尝试终于确定了记录分数的地址： 修改其初始值 得到答案 little_thief流量包分析 常规操作，导出http流查看是否存在有用信息： 好，导出 有密码，找 追踪tcp流逐个分析 拉到最上面可以发现是登录信息 以游客身份登陆的信息，没啥用，再找 一眼jwt 好，解一下 找到压缩包密码了 打开flag.html，爆搜没有搜到flag,应该是隐写 使用wbStego4.3open进行解密，没有密钥 得 Redcoast一堆二进制，转为16进制保存，得到压缩包 将压缩包里的图片按25x25的大小进行排列，得到一个二维码 exp1: 123456789101112from PIL import Imageimport binasciiimport base64a=Image.new(&#x27;RGB&#x27;,(2500,2500),&#x27;white&#x27;)n=0for i in range(25): for j in range(25): b=Image.open(f&#x27;./pic/&#123;n&#125;.png&#x27;) a.paste(b,(100*j,100*i)) n+=1a.save(&#x27;6.png&#x27;) 扫描，得到压缩包密码： 打开里面还是一堆数字+字母 cyberchef: 是一张图片，但是存在许多混乱的像素带： 用stegsolve或者写脚本将每一个像素点的rgb提取并转为ascii exp2: 123456789101112131415from PIL import Imageimg = Image.open(r&#x27;C:\\Users\\19682\\Desktop\\3.png&#x27;)pixel =[]imgSize = img.sizex, y = imgSize[0], imgSize[1] # (x1200, y750)for i in range(y): for j in range(x): pixel.append(img.getpixel((j, i)))message = &#x27;&#x27;for i in pixel: for j in i: message += chr(j)with open(&#x27;flag.txt&#x27;, &#x27;a&#x27;, encoding=&#x27;utf-8&#x27;) as f: f.write(message) f.close()","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"DASCTF-month11","slug":"DAS11","date":"2022-11-26T16:00:00.000Z","updated":"2022-12-07T12:48:52.002Z","comments":true,"path":"2022/11/27/DAS11/","link":"","permalink":"http://example.com/2022/11/27/DAS11/","excerpt":"","text":"七仙女下凡附件给了6张包含内容相同的图片 对比观察可发现几张图片宽高之间存在一定的比例关系 尝试使用stegsovle中的image combiner模块进行组合 image combiner中存在多种组合方式（包括异或、或、与等），鉴于本题宽高的特殊比例，选择其中的水平交错（Vertical interlace）与垂直交错（Horizontal interlace） 交错存在以下顺序： 先1和2拼，垂直交错增加宽度，拼出来图片的再和3拼进行水平交错加高，再和4拼，加宽，再和5，加高，和6，加宽，最后和7，加高 导出7张图片合并完的最终结果，打开，观察颜色通道： red 0处存在明显异常，使用数据提取，rgb均选择最低位 根据16进制，存在jpg文件，导出改后缀 EzUSB这道题，根据后面的flag应该考查的是对于ntfs格式的usb硬盘的dbr分区恢复（事实上也确实是，因为观察dbr扇区可发现是全空的 但选择取证大师直接嗦 拉到取证大师直接深度恢复可发现题目中说的机密文件的压缩包 导出，打开提示文件格式错误 使用winhex查看 说实话，第一直觉，缺文件头，但观察主体也不像个zip文件的16进制格式 后来发现，是将zip文件的16进制进行了倒序 逆过来，单独保存，打开 这里放上皓文学长手修usb的dbr扇区的链接 Orz Dink Kirby PC（复现）与内存取证有关 vol分析一下内存镜像 导出notepad.exe的进程 命令： 1volatility_2.6_win64_standalone -f 66.raw --profile=Win7SP1x64 memdump -p 3860 -D ./ 发现一个带锁的压缩包，结合passkit提取的电脑开机密码可以解开 这里的perl命令不是太会，但是大体上的意思应该是对$_PASSWORD进行了加密，我们可以尝试手撸爆破出来，当然也可以写脚本 TeamGipsy的exp: 12345678910111213import stringx=&#x27;878189096364096066836664&#x27;string1=&#x27;0123456789&#x27;string2=&#x27;8195376024&#x27;string3=string.digits+string.ascii_lowercasestring4=string.ascii_lowercase+string.digitsx=x.translate(str.maketrans(string2,string1))flag=&#x27;&#x27;for i in range(0,len(x),2): flag+=chr(int(x[i:i+2])^0x31)flag=flag.translate(str.maketrans(string3,string4))print(flag)#ead803812f23 得到了aes的密钥，那么aes呢？ 应该还在内存里，找吧 经过aes加密的字符串都以U2Fsd开头，我们可以直接搜关键字 理论上取证大师的原始数据应该也可以搜索到 现在我们解密 拿这个密码去解密附件给的encrypt.crypto文件 ok了","categories":[{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"}],"tags":[{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"}]},{"title":"迁移通知","slug":"test","date":"2022-11-24T16:00:00.000Z","updated":"2022-11-30T05:06:55.101Z","comments":true,"path":"2022/11/25/test/","link":"","permalink":"http://example.com/2022/11/25/test/","excerpt":"","text":"从最开始接触网安时使用的csdn,到后来利用腾讯云服务器和wordpress一步一步搭建的博客，再到最后的博客园 。最终还是选择了hexo+github搭建的静态博客网站。 csdn作为国内体量最大的IT学习平台，其资源量是巨大的，加上其较为完善的移动端app,有着不言而喻的便利性，无奈被其纷杂的广告劝退，但是用来搜集和学习知识还是不错的。 自己通过租用服务器并利用wordpress搭建的静态服务器，让自己对网站的结构有了更深刻的认识，然而不是每个大学牲都支付得起服务器的租金，加之服务器性能的原因，网站渲染起来很慢，最终没有再维护下去。 博客园相较于前两者，没有广告，加载起来也很快，还支持自定义js，可以满足博客的大部分需求，但是对我个人而言，还是更加青睐于一个没有后台的静态博客网站，因此最终选择了部署在github上的hexo。 目前还没有完全把hexo玩懂，愿我和我的小网站可以一起进步，一次成长吧！","categories":[{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}],"tags":[]}],"categories":[{"name":"wiki","slug":"wiki","permalink":"http://example.com/categories/wiki/"},{"name":"ctf","slug":"ctf","permalink":"http://example.com/categories/ctf/"},{"name":"随手记","slug":"随手记","permalink":"http://example.com/categories/%E9%9A%8F%E6%89%8B%E8%AE%B0/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://example.com/tags/docker/"},{"name":"比赛","slug":"比赛","permalink":"http://example.com/tags/%E6%AF%94%E8%B5%9B/"},{"name":"刷题记录","slug":"刷题记录","permalink":"http://example.com/tags/%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95/"}]}